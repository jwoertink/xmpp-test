;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Jingle = require('jingle')
, attachMediaStream = require('attachmediastream')
var socket = new Primus('https://xmpp-ftw.jit.su')
var jingle = new Jingle()
var loginInfo = document.getElementById('loginInfo')
var localStarted = false
loginInfo.onsubmit = function (e) {
if (e.preventDefault) e.preventDefault()
var jid = document.getElementById('jid').value
var username = jid.slice(0, jid.indexOf('@'))
console.log('Connected')
socket.send(
'xmpp.login', {
jid: jid,
password: document.getElementById('password').value,
host: document.getElementById('host').value,
resource: document.getElementById('resource').value || 'jingle-rocks'
}
)
socket.on('xmpp.connection', function(data) {
console.log('connected', data)
socket.send('xmpp.presence', {})
document.getElementById('myJID').textContent = data.jid.user +
'@' + data.jid.domain + '/' + data.jid.resource
})
jingle.on('incoming', function (session) {
console.log('incoming session', session)
session.accept()
})
jingle.on('peerStreamAdded', function(session) {
console.log('peerStreamAdded', session)
attachMediaStream(session.stream, document.getElementById('remoteVideo'))
})
jingle.on('localStream', function (stream) {
if (false === localStarted) {
attachMediaStream(stream, document.getElementById('localVideo'), { muted: true, mirror: true })
localStarted = true
}
})
jingle.on('send', function(data) {
if (data.jingle && (data.jingle.action == 'session-accept')) {
console.debug('sending', data)
window.jingleAccept = data
}
socket.send('xmpp.jingle.request', data, function(error, success) {
if (error) return console.error('Failed', error)
console.log(data.jingle.action + ' ack', success)
})
})
var callInfo = document.getElementById('callInfo')
callInfo.onsubmit = function (e) {
e.preventDefault()
var jid = document.getElementById('peer').value
jingle.startLocalMedia(null, function (error, stream) {
localStarted = true
var sess = jingle.createMediaSession(jid)
sess.start()
console.log('Calling ' + jid)
})
return false
}
return false
}
socket.on('xmpp.error.client', function(error) {
console.error(error)
})
jingle.startLocalMedia(null, function (error, stream) {
if (error) return console.error(error)
attachMediaStream(stream, document.getElementById('localVideo'), { muted: true, mirror: true })
localStarted = true
})
socket.on('xmpp.jingle.request', function(data) {
if (false === localStarted) {
jingle.startLocalMedia(null, function (error, stream) {
if (error) return console.error(error)
attachMediaStream(stream, document.getElementById('localVideo'), { muted: true, mirror: true })
})
localStarted = true
}
jingle.process(data)
})
},{"attachmediastream":2,"jingle":4}],2:[function(require,module,exports){
module.exports = function (stream, el, options) {
var URL = window.URL;
var opts = {
autoplay: true,
mirror: false,
muted: false
};
var element = el || document.createElement('video');
var item;
if (options) {
for (item in options) {
opts[item] = options[item];
}
}
if (opts.autoplay) element.autoplay = 'autoplay';
if (opts.muted) element.muted = true;
if (opts.mirror) {
['', 'moz', 'webkit', 'o', 'ms'].forEach(function (prefix) {
var styleName = prefix ? prefix + 'Transform' : 'transform';
element.style[styleName] = 'scaleX(-1)';
});
}
// this first one should work most everywhere now
// but we have a few fallbacks just in case.
if (URL && URL.createObjectURL) {
element.src = URL.createObjectURL(stream);
} else if (element.srcObject) {
element.srcObject = stream;
} else if (element.mozSrcObject) {
element.mozSrcObject = stream;
} else {
return false;
}
return element;
};
},{}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};
process.nextTick = (function () {
var canSetImmediate = typeof window !== 'undefined'
&& window.setImmediate;
var canPost = typeof window !== 'undefined'
&& window.postMessage && window.addEventListener
;
if (canSetImmediate) {
return function (f) { return window.setImmediate(f) };
}
if (canPost) {
var queue = [];
window.addEventListener('message', function (ev) {
var source = ev.source;
if ((source === window || source === null) && ev.data === 'process-tick') {
ev.stopPropagation();
if (queue.length > 0) {
var fn = queue.shift();
fn();
}
}
}, true);
return function nextTick(fn) {
queue.push(fn);
window.postMessage('process-tick', '*');
};
}
return function nextTick(fn) {
setTimeout(fn, 0);
};
})();
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.binding = function (name) {
throw new Error('process.binding is not supported');
}
// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
throw new Error('process.chdir is not supported');
};
},{}],4:[function(require,module,exports){
module.exports = require('./lib/sessionManager');
},{"./lib/sessionManager":7}],5:[function(require,module,exports){
var bows = require('bows');
var async = require('async');
var WildEmitter = require('wildemitter');
var JinglePeerConnection = require('jingle-rtcpeerconnection');
var JingleJSON = require('sdp-jingle-json');
var log = bows('JingleSession');
function actionToMethod(action) {
var words = action.split('-');
return 'on' + words[0][0].toUpperCase() + words[0].substr(1) + words[1][0].toUpperCase() + words[1].substr(1);
}
function JingleSession(opts) {
var self = this;
this.sid = opts.sid || Date.now().toString();
this.peer = opts.peer;
this.isInitiator = opts.initiator || false;
this.state = 'starting';
this.parent = opts.parent;
this.processingQueue = async.queue(function (task, next) {
var action = task.action;
var changes = task.changes;
var cb = task.cb;
log(self.sid + ': ' + action);
self[action](changes, function (err) {
cb(err);
next();
});
});
}
JingleSession.prototype = Object.create(WildEmitter.prototype, {
constructor: {
value: JingleSession
}
});
JingleSession.prototype.process = function (action, changes, cb) {
var self = this;
var method = actionToMethod(action);
this.processingQueue.push({
action: method,
changes: changes,
cb: cb
});
};
JingleSession.prototype.send = function (type, data) {
data = data || {};
data.sid = this.sid;
data.action = type;
this.parent.emit('send', {
to: this.peer,
type: 'set',
jingle: data
});
};
Object.defineProperty(JingleSession.prototype, 'state', {
get: function () {
return this._state;
},
set: function (value) {
var validStates = {
starting: true,
pending: true,
active: true,
ended: true
};
if (!validStates[value]) {
throw new Error('Invalid Jingle Session State: ' + value);
}
if (this._state !== value) {
this._state = value;
log(this.sid + ': State changed to ' + value);
}
}
});
Object.defineProperty(JingleSession.prototype, 'starting', {
get: function () {
return this._state == 'starting';
}
});
Object.defineProperty(JingleSession.prototype, 'pending', {
get: function () {
return this._state == 'pending';
}
});
Object.defineProperty(JingleSession.prototype, 'active', {
get: function () {
return this._state == 'active';
}
});
Object.defineProperty(JingleSession.prototype, 'ended', {
get: function () {
return this._state == 'ended';
}
});
JingleSession.prototype.start = function () {
this.state = 'pending';
log(this.sid + ': Can not start generic session');
};
JingleSession.prototype.end = function (reason, silence) {
this.parent.peers[this.peer].splice(this.parent.peers[this.peer].indexOf(this), 1);
delete this.parent.sessions[this.sid];
this.state = 'ended';
reason = reason || {};
if (!silence) {
this.send('session-terminate', {reason: reason});
}
this.parent.emit('terminated', this, reason);
};
var actions = [
'content-accept', 'content-add', 'content-modify',
'conent-reject', 'content-remove', 'description-info',
'session-accept', 'session-info', 'session-initiate',
'session-terminate', 'transport-accept', 'transport-info',
'transport-reject', 'transport-replace'
];
actions.forEach(function (action) {
var method = actionToMethod(action);
JingleSession.prototype[method] = function (changes, cb) {
log(this.sid + ': Unsupported action ' + action);
cb();
};
});
module.exports = JingleSession;
},{"async":8,"bows":9,"jingle-rtcpeerconnection":13,"sdp-jingle-json":18,"wildemitter":24}],6:[function(require,module,exports){
var _ = require('underscore');
var bows = require('bows');
var JingleSession = require('./genericSession');
var JinglePeerConnection = require('jingle-rtcpeerconnection');
var log = bows('JingleMedia');
function MediaSession(opts) {
JingleSession.call(this, opts);
var self = this;
this.pc = new JinglePeerConnection(this.parent.config.peerConnectionConfig,
this.parent.config.peerConnectionConstraints);
this.pc.on('ice', this.onIceCandidate.bind(this));
this.pc.on('addStream', this.onStreamAdded.bind(this));
this.pc.on('removeStream', this.onStreamRemoved.bind(this));
this.pendingAnswer = null;
if (this.parent.localStream) {
this.pc.addStream(this.parent.localStream);
this.localStream = this.parent.localStream;
} else {
this.parent.once('localStream', function (stream) {
self.pc.addStream(stream);
this.localStream = stream;
});
}
this.stream = null;
}
MediaSession.prototype = Object.create(JingleSession.prototype, {
constructor: {
value: MediaSession
}
});
MediaSession.prototype = _.extend(MediaSession.prototype, {
start: function () {
var self = this;
this.state = 'pending';
this.pc.isInitiator = true;
this.pc.offer(function (err, sessDesc) {
self.send('session-initiate', sessDesc.json);
});
},
end: function (reason) {
this.pc.close();
this.onStreamRemoved();
JingleSession.prototype.end.call(this, reason);
},
accept: function () {
log(this.sid + ': Accepted incoming session');
this.state = 'active';
this.send('session-accept', this.pendingAnswer);
},
ring: function () {
log(this.sid + ': Ringing on incoming session');
this.send('session-info', {ringing: true});
},
mute: function (creator, name) {
log(this.sid + ': Muting');
this.send('session-info', {mute: {creator: creator, name: name}});
},
unmute: function (creator, name) {
log(this.sid + ': Unmuting');
this.send('session-info', {unmute: {creator: creator, name: name}});
},
hold: function () {
log(this.sid + ': Placing on hold');
this.send('session-info', {hold: true});
},
resume: function () {
log(this.sid + ': Resuing from hold');
this.send('session-info', {active: true});
},
onSessionInitiate: function (changes, cb) {
log(this.sid + ': Initiating incoming session');
var self = this;
this.state = 'pending';
this.pc.isInitiator = false;
this.pc.answer({type: 'offer', json: changes}, function (err, answer) {
if (err) {
log(self.sid + ': Could not create WebRTC answer', err);
return cb({condition: 'general-error'});
}
self.pendingAnswer = answer.json;
cb();
});
},
onSessionAccept: function (changes, cb) {
var self = this;
log(this.sid + ': Activating accepted outbound session');
this.state = 'active';
this.pc.handleAnswer({type: 'answer', json: changes}, function (err) {
if (err) {
log(self.sid + ': Could not process WebRTC answer', err);
return cb({condition: 'general-error'});
}
self.parent.emit('accepted', self);
cb();
});
},
onSessionTerminate: function (changes, cb) {
log(this.sid + ': Terminating session');
this.pc.close();
this.onStreamRemoved();
JingleSession.prototype.end.call(this, changes.reason, true);
cb();
},
onTransportInfo: function (changes, cb) {
var self = this;
log(this.sid + ': Adding ICE candidate');
this.pc.processIce(changes, function (err) {
if (err) {
log(self.sid + ': Could not process ICE candidate', err);
}
cb();
});
},
onSessionInfo: function (info, cb) {
log(info);
if (info.ringing) {
log(this.sid + ': Ringing on remote stream');
this.parent.emit('ringing', this);
}
if (info.hold) {
log(this.sid + ': On hold');
this.parent.emit('hold', this);
}
if (info.active) {
log(this.sid + ': Resumed from hold');
this.parent.emit('resumed', this);
}
if (info.mute) {
log(this.sid + ': Muted', info.mute);
this.parent.emit('mute', this, info.mute);
}
if (info.unmute) {
log(this.sid + ': Unmuted', info.unmute);
this.parent.emit('unmute', this, info.unmute);
}
cb();
},
onIceCandidate: function (candidateInfo) {
log(this.sid + ': Discovered new ICE candidate', candidateInfo);
this.send('transport-info', candidateInfo);
},
onStreamAdded: function (event) {
if (this.stream) {
log(this.sid + ': Received remote stream, but one already exists');
} else {
log(this.sid + ': Remote media stream added');
this.stream = event.stream;
this.parent.emit('peerStreamAdded', this);
}
},
onStreamRemoved: function () {
log(this.sid + ': Remote media stream removed');
this.parent.emit('peerStreamRemoved', this);
}
});
module.exports = MediaSession;
},{"./genericSession":5,"bows":9,"jingle-rtcpeerconnection":13,"underscore":22}],7:[function(require,module,exports){
var _ = require('underscore');
var bows = require('bows');
var hark = require('hark');
var webrtc = require('webrtcsupport');
var mockconsole = require('mockconsole');
var getUserMedia = require('getusermedia');
var JinglePeerConnection = require('jingle-rtcpeerconnection');
var WildEmitter = require('wildemitter');
var GainController = require('mediastream-gain');
var GenericSession = require('./genericSession');
var MediaSession = require('./mediaSession');
var log = bows('Jingle');
function Jingle(opts) {
var self = this;
opts = opts || {};
var config = this.config = {
debug: false,
peerConnectionConfig: {
iceServers: [{"url": "stun:stun.l.google.com:19302"}]
},
peerConnectionConstraints: {
optional: [
{DtlsSrtpKeyAgreement: true},
{RtpDataChannels: false}
]
},
autoAdjustMic: false,
media: {
audio: true,
video: true
}
};
this.MediaSession = MediaSession;
this.jid = opts.jid;
this.sessions = {};
this.peers = {};
this.screenSharingSupport = webrtc.screenSharing;
for (var item in opts) {
config[item] = opts[item];
}
this.capabilities = [
'urn:xmpp:jingle:1'
];
if (webrtc.support) {
this.capabilities = [
'urn:xmpp:jingle:1',
'urn:xmpp:jingle:apps:rtp:1',
'urn:xmpp:jingle:apps:rtp:audio',
'urn:xmpp:jingle:apps:rtp:video',
'urn:xmpp:jingle:apps:rtp:rtcb-fb:0',
'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',
'urn:xmpp:jingle:apps:dtls:0',
'urn:xmpp:jingle:transports:ice-udp:1',
'urn:ietf:rfc:3264'
];
} else {
log('WebRTC not supported');
}
WildEmitter.call(this);
if (this.config.debug) {
this.on('*', function (event, val1, val2) {
log(event, val1, val2);
});
}
}
Jingle.prototype = Object.create(WildEmitter.prototype, {
constructor: {
value: Jingle
}
});
Jingle.prototype.addICEServer = function (server) {
this.config.peerConnectionConfig.iceServers.push(server);
};
Jingle.prototype.startLocalMedia = function (mediaConstraints, cb) {
var self = this;
var constraints = mediaConstraints || {video: true, audio: true};
getUserMedia(constraints, function (err, stream) {
if (!err) {
if (constraints.audio && self.config.detectSpeakingEvents) {
self.setupAudioMonitor(stream);
}
self.localStream = stream;
if (self.config.autoAdjustMic) {
self.gainController = new GainController(stream);
self.setMicIfEnabled(0.5);
}
log('Local media stream started');
self.emit('localStream', stream);
} else {
log('Could not start local media');
}
if (cb) cb(err, stream);
});
};
Jingle.prototype.stopLocalMedia = function () {
if (this.localStream) {
this.localStream.stop();
this.emit('localStreamStopped');
}
};
Jingle.prototype.setupAudioMonitor = function (stream) {
log('Setup audio');
var audio = hark(stream);
var self = this;
var timeout;
audio.on('speaking', function () {
if (self.hardMuted) return;
self.setMicIfEnabled(1);
self.emit('speaking');
});
audio.on('stopped_speaking', function () {
if (self.hardMuted) return;
if (timeout) clearTimeout(timeout);
timeout = setTimeout(function () {
self.setMicIfEnabled(0.5);
self.emit('stoppedSpeaking');
}, 1000);
});
};
Jingle.prototype.setMicIfEnabled = function (volume) {
if (!this.config.autoAdjustMic) return;
this.gainController.setGain(volume);
};
Jingle.prototype.sendError = function (to, id, data) {
data.type = 'cancel';
this.emit('send', {
to: to,
id: id,
type: 'error',
error: data
});
};
Jingle.prototype.process = function (req) {
var self = this;
if (req.type === 'error') {
return this.emit('error', req);
}
if (req.type === 'result') {
return;
}
var sids, currsid, sess;
var sid = req.jingle.sid;
var action = req.jingle.action;
var contents = req.jingle.contents || [];
var contentTypes = _.map(contents, function (content) {
return (content.description || {}).descType;
});
var session = this.sessions[sid] || null;
var sender = req.from.full || req.from;
var reqid = req.id;
if (action !== 'session-initiate') {
// Can't modify a session that we don't have.
if (!session) {
log('Unknown session', sid);
return this.sendError(sender, reqid, {
condition: 'item-not-found',
jingleCondition: 'unknown-session'
});
}
// Check if someone is trying to hijack a session.
if (session.peer !== sender || session.ended) {
log('Session has ended, or action has wrong sender');
return this.sendError(sender, reqid, {
condition: 'item-not-found',
jingleCondition: 'unknown-session'
});
}
// Can't accept a session twice
if (action === 'session-accept' && !session.pending) {
log('Tried to accept session twice', sid);
return this.sendError(sender, reqid, {
condition: 'unexpected-request',
jingleCondition: 'out-of-order'
});
}
// Can't process two requests at once, need to tie break
if (action !== 'session-terminate' && session.pendingAction) {
log('Tie break during pending request');
if (session.isInitiator) {
return this.sendError(sender, reqid, {
condition: 'conflict',
jingleCondition: 'tie-break'
});
}
}
} else if (session) {
// Don't accept a new session if we already have one.
if (session.peer !== sender) {
log('Duplicate sid from new sender');
return this.sendError(sender, reqid, {
condition: 'service-unavailable'
});
}
// Check if we need to have a tie breaker because both parties
// happened to pick the same random sid.
if (session.pending) {
if (this.jid > session.peer) {
log('Tie break new session because of duplicate sids');
return this.sendError(sender, reqid, {
condition: 'conflict',
jingleCondition: 'tie-break'
});
}
}
// The other side is just doing it wrong.
log('Someone is doing this wrong');
return this.sendError(sender, reqid, {
condition: 'unexpected-request',
jingleCondition: 'out-of-order'
});
} else if (Object.keys(this.peers[sender] || {}).length) {
// Check if we need to have a tie breaker because we already have
// a different session that is using the requested content types.
sids = Object.keys(this.peers[sender]);
for (var i = 0; i < sids.length; i++) {
currsid = sids[i];
sess = this.sessions[currsid];
if (sess.pending) {
if (_.intersection(contentTypes, sess.contentTypes).length) {
// We already have a pending session request for this content type.
if (currsid > sid) {
// We won the tie breaker
log('Tie break');
return this.sendError(sender, reqid, {
condition: 'conflict',
jingleCondition: 'tie-break'
});
}
}
}
}
}
if (action === 'session-initiate') {
var opts = {
sid: sid,
peer: sender,
initiator: false,
parent: this
};
if (contentTypes.indexOf('rtp') >= 0) {
session = new MediaSession(opts);
} else {
session = new GenericSession(opts);
}
this.sessions[sid] = session;
if (!this.peers[sender]) {
this.peers[sender] = [];
}
this.peers[sender].push(session);
}
session.process(action, req.jingle, function (err) {
if (err) {
log('Could not process request', req, err);
self.sendError(sender, reqid, err);
} else {
self.emit(
'send',
{ to: sender, id: reqid, type: 'result', action: action }
);
if (action === 'session-initiate') {
log('Incoming session request from ', sender, session);
self.emit('incoming', session);
}
}
});
};
Jingle.prototype.createMediaSession = function (peer, sid) {
var session = new MediaSession({
sid: sid,
peer: peer,
initiator: true,
parent: this
});
sid = session.sid;
this.sessions[sid] = session;
if (!this.peers[peer]) {
this.peers[peer] = [];
}
this.peers[peer].push(session);
log('Outgoing session', session.sid, session);
this.emit('outgoing', session);
return session;
};
Jingle.prototype.endPeerSessions = function (peer) {
log('Ending all sessions with', peer);
var sessions = this.peers[peer] || [];
sessions.forEach(function (session) {
session.end();
});
};
module.exports = Jingle;
},{"./genericSession":5,"./mediaSession":6,"bows":9,"getusermedia":11,"hark":12,"jingle-rtcpeerconnection":13,"mediastream-gain":15,"mockconsole":17,"underscore":22,"webrtcsupport":23,"wildemitter":24}],8:[function(require,module,exports){
var process=require("__browserify_process");/*global setImmediate: false, setTimeout: false, console: false */
(function () {
var async = {};
// global on the server, window in the browser
var root, previous_async;
root = this;
if (root != null) {
previous_async = root.async;
}
async.noConflict = function () {
root.async = previous_async;
return async;
};
function only_once(fn) {
var called = false;
return function() {
if (called) throw new Error("Callback was already called.");
called = true;
fn.apply(root, arguments);
}
}
//// cross-browser compatiblity functions ////
var _each = function (arr, iterator) {
if (arr.forEach) {
return arr.forEach(iterator);
}
for (var i = 0; i < arr.length; i += 1) {
iterator(arr[i], i, arr);
}
};
var _map = function (arr, iterator) {
if (arr.map) {
return arr.map(iterator);
}
var results = [];
_each(arr, function (x, i, a) {
results.push(iterator(x, i, a));
});
return results;
};
var _reduce = function (arr, iterator, memo) {
if (arr.reduce) {
return arr.reduce(iterator, memo);
}
_each(arr, function (x, i, a) {
memo = iterator(memo, x, i, a);
});
return memo;
};
var _keys = function (obj) {
if (Object.keys) {
return Object.keys(obj);
}
var keys = [];
for (var k in obj) {
if (obj.hasOwnProperty(k)) {
keys.push(k);
}
}
return keys;
};
//// exported async module functions ////
//// nextTick implementation with browser-compatible fallback ////
if (typeof process === 'undefined' || !(process.nextTick)) {
if (typeof setImmediate === 'function') {
async.nextTick = function (fn) {
// not a direct alias for IE10 compatibility
setImmediate(fn);
};
async.setImmediate = async.nextTick;
}
else {
async.nextTick = function (fn) {
setTimeout(fn, 0);
};
async.setImmediate = async.nextTick;
}
}
else {
async.nextTick = process.nextTick;
if (typeof setImmediate !== 'undefined') {
async.setImmediate = setImmediate;
}
else {
async.setImmediate = async.nextTick;
}
}
async.each = function (arr, iterator, callback) {
callback = callback || function () {};
if (!arr.length) {
return callback();
}
var completed = 0;
_each(arr, function (x) {
iterator(x, only_once(function (err) {
if (err) {
callback(err);
callback = function () {};
}
else {
completed += 1;
if (completed >= arr.length) {
callback(null);
}
}
}));
});
};
async.forEach = async.each;
async.eachSeries = function (arr, iterator, callback) {
callback = callback || function () {};
if (!arr.length) {
return callback();
}
var completed = 0;
var iterate = function () {
iterator(arr[completed], function (err) {
if (err) {
callback(err);
callback = function () {};
}
else {
completed += 1;
if (completed >= arr.length) {
callback(null);
}
else {
iterate();
}
}
});
};
iterate();
};
async.forEachSeries = async.eachSeries;
async.eachLimit = function (arr, limit, iterator, callback) {
var fn = _eachLimit(limit);
fn.apply(null, [arr, iterator, callback]);
};
async.forEachLimit = async.eachLimit;
var _eachLimit = function (limit) {
return function (arr, iterator, callback) {
callback = callback || function () {};
if (!arr.length || limit <= 0) {
return callback();
}
var completed = 0;
var started = 0;
var running = 0;
(function replenish () {
if (completed >= arr.length) {
return callback();
}
while (running < limit && started < arr.length) {
started += 1;
running += 1;
iterator(arr[started - 1], function (err) {
if (err) {
callback(err);
callback = function () {};
}
else {
completed += 1;
running -= 1;
if (completed >= arr.length) {
callback();
}
else {
replenish();
}
}
});
}
})();
};
};
var doParallel = function (fn) {
return function () {
var args = Array.prototype.slice.call(arguments);
return fn.apply(null, [async.each].concat(args));
};
};
var doParallelLimit = function(limit, fn) {
return function () {
var args = Array.prototype.slice.call(arguments);
return fn.apply(null, [_eachLimit(limit)].concat(args));
};
};
var doSeries = function (fn) {
return function () {
var args = Array.prototype.slice.call(arguments);
return fn.apply(null, [async.eachSeries].concat(args));
};
};
var _asyncMap = function (eachfn, arr, iterator, callback) {
var results = [];
arr = _map(arr, function (x, i) {
return {index: i, value: x};
});
eachfn(arr, function (x, callback) {
iterator(x.value, function (err, v) {
results[x.index] = v;
callback(err);
});
}, function (err) {
callback(err, results);
});
};
async.map = doParallel(_asyncMap);
async.mapSeries = doSeries(_asyncMap);
async.mapLimit = function (arr, limit, iterator, callback) {
return _mapLimit(limit)(arr, iterator, callback);
};
var _mapLimit = function(limit) {
return doParallelLimit(limit, _asyncMap);
};
// reduce only has a series version, as doing reduce in parallel won't
// work in many situations.
async.reduce = function (arr, memo, iterator, callback) {
async.eachSeries(arr, function (x, callback) {
iterator(memo, x, function (err, v) {
memo = v;
callback(err);
});
}, function (err) {
callback(err, memo);
});
};
// inject alias
async.inject = async.reduce;
// foldl alias
async.foldl = async.reduce;
async.reduceRight = function (arr, memo, iterator, callback) {
var reversed = _map(arr, function (x) {
return x;
}).reverse();
async.reduce(reversed, memo, iterator, callback);
};
// foldr alias
async.foldr = async.reduceRight;
var _filter = function (eachfn, arr, iterator, callback) {
var results = [];
arr = _map(arr, function (x, i) {
return {index: i, value: x};
});
eachfn(arr, function (x, callback) {
iterator(x.value, function (v) {
if (v) {
results.push(x);
}
callback();
});
}, function (err) {
callback(_map(results.sort(function (a, b) {
return a.index - b.index;
}), function (x) {
return x.value;
}));
});
};
async.filter = doParallel(_filter);
async.filterSeries = doSeries(_filter);
// select alias
async.select = async.filter;
async.selectSeries = async.filterSeries;
var _reject = function (eachfn, arr, iterator, callback) {
var results = [];
arr = _map(arr, function (x, i) {
return {index: i, value: x};
});
eachfn(arr, function (x, callback) {
iterator(x.value, function (v) {
if (!v) {
results.push(x);
}
callback();
});
}, function (err) {
callback(_map(results.sort(function (a, b) {
return a.index - b.index;
}), function (x) {
return x.value;
}));
});
};
async.reject = doParallel(_reject);
async.rejectSeries = doSeries(_reject);
var _detect = function (eachfn, arr, iterator, main_callback) {
eachfn(arr, function (x, callback) {
iterator(x, function (result) {
if (result) {
main_callback(x);
main_callback = function () {};
}
else {
callback();
}
});
}, function (err) {
main_callback();
});
};
async.detect = doParallel(_detect);
async.detectSeries = doSeries(_detect);
async.some = function (arr, iterator, main_callback) {
async.each(arr, function (x, callback) {
iterator(x, function (v) {
if (v) {
main_callback(true);
main_callback = function () {};
}
callback();
});
}, function (err) {
main_callback(false);
});
};
// any alias
async.any = async.some;
async.every = function (arr, iterator, main_callback) {
async.each(arr, function (x, callback) {
iterator(x, function (v) {
if (!v) {
main_callback(false);
main_callback = function () {};
}
callback();
});
}, function (err) {
main_callback(true);
});
};
// all alias
async.all = async.every;
async.sortBy = function (arr, iterator, callback) {
async.map(arr, function (x, callback) {
iterator(x, function (err, criteria) {
if (err) {
callback(err);
}
else {
callback(null, {value: x, criteria: criteria});
}
});
}, function (err, results) {
if (err) {
return callback(err);
}
else {
var fn = function (left, right) {
var a = left.criteria, b = right.criteria;
return a < b ? -1 : a > b ? 1 : 0;
};
callback(null, _map(results.sort(fn), function (x) {
return x.value;
}));
}
});
};
async.auto = function (tasks, callback) {
callback = callback || function () {};
var keys = _keys(tasks);
if (!keys.length) {
return callback(null);
}
var results = {};
var listeners = [];
var addListener = function (fn) {
listeners.unshift(fn);
};
var removeListener = function (fn) {
for (var i = 0; i < listeners.length; i += 1) {
if (listeners[i] === fn) {
listeners.splice(i, 1);
return;
}
}
};
var taskComplete = function () {
_each(listeners.slice(0), function (fn) {
fn();
});
};
addListener(function () {
if (_keys(results).length === keys.length) {
callback(null, results);
callback = function () {};
}
});
_each(keys, function (k) {
var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
var taskCallback = function (err) {
var args = Array.prototype.slice.call(arguments, 1);
if (args.length <= 1) {
args = args[0];
}
if (err) {
var safeResults = {};
_each(_keys(results), function(rkey) {
safeResults[rkey] = results[rkey];
});
safeResults[k] = args;
callback(err, safeResults);
// stop subsequent errors hitting callback multiple times
callback = function () {};
}
else {
results[k] = args;
async.setImmediate(taskComplete);
}
};
var requires = task.slice(0, Math.abs(task.length - 1)) || [];
var ready = function () {
return _reduce(requires, function (a, x) {
return (a && results.hasOwnProperty(x));
}, true) && !results.hasOwnProperty(k);
};
if (ready()) {
task[task.length - 1](taskCallback, results);
}
else {
var listener = function () {
if (ready()) {
removeListener(listener);
task[task.length - 1](taskCallback, results);
}
};
addListener(listener);
}
});
};
async.waterfall = function (tasks, callback) {
callback = callback || function () {};
if (tasks.constructor !== Array) {
var err = new Error('First argument to waterfall must be an array of functions');
return callback(err);
}
if (!tasks.length) {
return callback();
}
var wrapIterator = function (iterator) {
return function (err) {
if (err) {
callback.apply(null, arguments);
callback = function () {};
}
else {
var args = Array.prototype.slice.call(arguments, 1);
var next = iterator.next();
if (next) {
args.push(wrapIterator(next));
}
else {
args.push(callback);
}
async.setImmediate(function () {
iterator.apply(null, args);
});
}
};
};
wrapIterator(async.iterator(tasks))();
};
var _parallel = function(eachfn, tasks, callback) {
callback = callback || function () {};
if (tasks.constructor === Array) {
eachfn.map(tasks, function (fn, callback) {
if (fn) {
fn(function (err) {
var args = Array.prototype.slice.call(arguments, 1);
if (args.length <= 1) {
args = args[0];
}
callback.call(null, err, args);
});
}
}, callback);
}
else {
var results = {};
eachfn.each(_keys(tasks), function (k, callback) {
tasks[k](function (err) {
var args = Array.prototype.slice.call(arguments, 1);
if (args.length <= 1) {
args = args[0];
}
results[k] = args;
callback(err);
});
}, function (err) {
callback(err, results);
});
}
};
async.parallel = function (tasks, callback) {
_parallel({ map: async.map, each: async.each }, tasks, callback);
};
async.parallelLimit = function(tasks, limit, callback) {
_parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
};
async.series = function (tasks, callback) {
callback = callback || function () {};
if (tasks.constructor === Array) {
async.mapSeries(tasks, function (fn, callback) {
if (fn) {
fn(function (err) {
var args = Array.prototype.slice.call(arguments, 1);
if (args.length <= 1) {
args = args[0];
}
callback.call(null, err, args);
});
}
}, callback);
}
else {
var results = {};
async.eachSeries(_keys(tasks), function (k, callback) {
tasks[k](function (err) {
var args = Array.prototype.slice.call(arguments, 1);
if (args.length <= 1) {
args = args[0];
}
results[k] = args;
callback(err);
});
}, function (err) {
callback(err, results);
});
}
};
async.iterator = function (tasks) {
var makeCallback = function (index) {
var fn = function () {
if (tasks.length) {
tasks[index].apply(null, arguments);
}
return fn.next();
};
fn.next = function () {
return (index < tasks.length - 1) ? makeCallback(index + 1): null;
};
return fn;
};
return makeCallback(0);
};
async.apply = function (fn) {
var args = Array.prototype.slice.call(arguments, 1);
return function () {
return fn.apply(
null, args.concat(Array.prototype.slice.call(arguments))
);
};
};
var _concat = function (eachfn, arr, fn, callback) {
var r = [];
eachfn(arr, function (x, cb) {
fn(x, function (err, y) {
r = r.concat(y || []);
cb(err);
});
}, function (err) {
callback(err, r);
});
};
async.concat = doParallel(_concat);
async.concatSeries = doSeries(_concat);
async.whilst = function (test, iterator, callback) {
if (test()) {
iterator(function (err) {
if (err) {
return callback(err);
}
async.whilst(test, iterator, callback);
});
}
else {
callback();
}
};
async.doWhilst = function (iterator, test, callback) {
iterator(function (err) {
if (err) {
return callback(err);
}
if (test()) {
async.doWhilst(iterator, test, callback);
}
else {
callback();
}
});
};
async.until = function (test, iterator, callback) {
if (!test()) {
iterator(function (err) {
if (err) {
return callback(err);
}
async.until(test, iterator, callback);
});
}
else {
callback();
}
};
async.doUntil = function (iterator, test, callback) {
iterator(function (err) {
if (err) {
return callback(err);
}
if (!test()) {
async.doUntil(iterator, test, callback);
}
else {
callback();
}
});
};
async.queue = function (worker, concurrency) {
if (concurrency === undefined) {
concurrency = 1;
}
function _insert(q, data, pos, callback) {
if(data.constructor !== Array) {
data = [data];
}
_each(data, function(task) {
var item = {
data: task,
callback: typeof callback === 'function' ? callback : null
};
if (pos) {
q.tasks.unshift(item);
} else {
q.tasks.push(item);
}
if (q.saturated && q.tasks.length === concurrency) {
q.saturated();
}
async.setImmediate(q.process);
});
}
var workers = 0;
var q = {
tasks: [],
concurrency: concurrency,
saturated: null,
empty: null,
drain: null,
push: function (data, callback) {
_insert(q, data, false, callback);
},
unshift: function (data, callback) {
_insert(q, data, true, callback);
},
process: function () {
if (workers < q.concurrency && q.tasks.length) {
var task = q.tasks.shift();
if (q.empty && q.tasks.length === 0) {
q.empty();
}
workers += 1;
var next = function () {
workers -= 1;
if (task.callback) {
task.callback.apply(task, arguments);
}
if (q.drain && q.tasks.length + workers === 0) {
q.drain();
}
q.process();
};
var cb = only_once(next);
worker(task.data, cb);
}
},
length: function () {
return q.tasks.length;
},
running: function () {
return workers;
}
};
return q;
};
async.cargo = function (worker, payload) {
var working = false,
tasks = [];
var cargo = {
tasks: tasks,
payload: payload,
saturated: null,
empty: null,
drain: null,
push: function (data, callback) {
if(data.constructor !== Array) {
data = [data];
}
_each(data, function(task) {
tasks.push({
data: task,
callback: typeof callback === 'function' ? callback : null
});
if (cargo.saturated && tasks.length === payload) {
cargo.saturated();
}
});
async.setImmediate(cargo.process);
},
process: function process() {
if (working) return;
if (tasks.length === 0) {
if(cargo.drain) cargo.drain();
return;
}
var ts = typeof payload === 'number'
? tasks.splice(0, payload)
: tasks.splice(0);
var ds = _map(ts, function (task) {
return task.data;
});
if(cargo.empty) cargo.empty();
working = true;
worker(ds, function () {
working = false;
var args = arguments;
_each(ts, function (data) {
if (data.callback) {
data.callback.apply(null, args);
}
});
process();
});
},
length: function () {
return tasks.length;
},
running: function () {
return working;
}
};
return cargo;
};
var _console_fn = function (name) {
return function (fn) {
var args = Array.prototype.slice.call(arguments, 1);
fn.apply(null, args.concat([function (err) {
var args = Array.prototype.slice.call(arguments, 1);
if (typeof console !== 'undefined') {
if (err) {
if (console.error) {
console.error(err);
}
}
else if (console[name]) {
_each(args, function (x) {
console[name](x);
});
}
}
}]));
};
};
async.log = _console_fn('log');
async.dir = _console_fn('dir');
/*async.info = _console_fn('info');
async.warn = _console_fn('warn');
async.error = _console_fn('error');*/
async.memoize = function (fn, hasher) {
var memo = {};
var queues = {};
hasher = hasher || function (x) {
return x;
};
var memoized = function () {
var args = Array.prototype.slice.call(arguments);
var callback = args.pop();
var key = hasher.apply(null, args);
if (key in memo) {
callback.apply(null, memo[key]);
}
else if (key in queues) {
queues[key].push(callback);
}
else {
queues[key] = [callback];
fn.apply(null, args.concat([function () {
memo[key] = arguments;
var q = queues[key];
delete queues[key];
for (var i = 0, l = q.length; i < l; i++) {
q[i].apply(null, arguments);
}
}]));
}
};
memoized.memo = memo;
memoized.unmemoized = fn;
return memoized;
};
async.unmemoize = function (fn) {
return function () {
return (fn.unmemoized || fn).apply(null, arguments);
};
};
async.times = function (count, iterator, callback) {
var counter = [];
for (var i = 0; i < count; i++) {
counter.push(i);
}
return async.map(counter, iterator, callback);
};
async.timesSeries = function (count, iterator, callback) {
var counter = [];
for (var i = 0; i < count; i++) {
counter.push(i);
}
return async.mapSeries(counter, iterator, callback);
};
async.compose = function (/* functions... */) {
var fns = Array.prototype.reverse.call(arguments);
return function () {
var that = this;
var args = Array.prototype.slice.call(arguments);
var callback = args.pop();
async.reduce(fns, args, function (newargs, fn, cb) {
fn.apply(that, newargs.concat([function () {
var err = arguments[0];
var nextargs = Array.prototype.slice.call(arguments, 1);
cb(err, nextargs);
}]))
},
function (err, results) {
callback.apply(that, [err].concat(results));
});
};
};
var _applyEach = function (eachfn, fns /*args...*/) {
var go = function () {
var that = this;
var args = Array.prototype.slice.call(arguments);
var callback = args.pop();
return eachfn(fns, function (fn, cb) {
fn.apply(that, args.concat([cb]));
},
callback);
};
if (arguments.length > 2) {
var args = Array.prototype.slice.call(arguments, 2);
return go.apply(this, args);
}
else {
return go;
}
};
async.applyEach = doParallel(_applyEach);
async.applyEachSeries = doSeries(_applyEach);
async.forever = function (fn, callback) {
function next(err) {
if (err) {
if (callback) {
return callback(err);
}
throw err;
}
fn(next);
}
next();
};
// AMD / RequireJS
if (typeof define !== 'undefined' && define.amd) {
define([], function () {
return async;
});
}
// Node.js
else if (typeof module !== 'undefined' && module.exports) {
module.exports = async;
}
// included directly via <script> tag
else {
root.async = async;
}
}());
},{"__browserify_process":3}],9:[function(require,module,exports){
(function() {
var inNode = typeof window === 'undefined',
ls = !inNode && window.localStorage,
debug = ls.debug,
logger = require('andlog'),
goldenRatio = 0.618033988749895,
hue = 0,
padLength = 15,
noop = function() {},
yieldColor,
bows,
debugRegex;
yieldColor = function() {
hue += goldenRatio;
hue = hue % 1;
return hue * 360;
};
var debugRegex = debug && debug[0]==='/' && new RegExp(debug.substring(1,debug.length-1));
bows = function(str) {
var msg;
msg = "%c" + (str.slice(0, padLength));
msg += Array(padLength + 3 - msg.length).join(' ') + '|';
if (debugRegex && !str.match(debugRegex)) return noop;
if (!window.chrome) return logger.log.bind(logger, msg);
return logger.log.bind(logger, msg, "color: hsl(" + (yieldColor()) + ",99%,40%); font-weight: bold");
};
bows.config = function(config) {
if (config.padLength) {
return padLength = config.padLength;
}
};
if (typeof module !== 'undefined') {
module.exports = bows;
} else {
window.bows = bows;
}
}).call();
},{"andlog":10}],10:[function(require,module,exports){
// follow @HenrikJoreteg and @andyet if you like this ;)
(function () {
var inNode = typeof window === 'undefined',
ls = !inNode && window.localStorage,
out = {};
if (inNode) {
module.exports = console;
return;
}
if (ls && ls.debug && window.console) {
out = window.console;
} else {
var methods = "assert,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,time,timeEnd,trace,warn".split(","),
l = methods.length,
fn = function () {};
while (l--) {
out[methods[l]] = fn;
}
}
if (typeof exports !== 'undefined') {
module.exports = out;
} else {
window.console = out;
}
})();
},{}],11:[function(require,module,exports){
// getUserMedia helper by @HenrikJoreteg
var func = (navigator.getUserMedia ||
navigator.webkitGetUserMedia ||
navigator.mozGetUserMedia ||
navigator.msGetUserMedia);
module.exports = function (constraints, cb) {
var options;
var haveOpts = arguments.length === 2;
var defaultOpts = {video: true, audio: true};
var error;
var denied = 'PERMISSION_DENIED';
var notSatified = 'CONSTRAINT_NOT_SATISFIED';
// make constraints optional
if (!haveOpts) {
cb = constraints;
constraints = defaultOpts;
}
// treat lack of browser support like an error
if (!func) {
// throw proper error per spec
error = new Error('NavigatorUserMediaError');
error.name = 'NOT_SUPPORTED_ERROR';
return cb(error);
}
func.call(navigator, constraints, function (stream) {
cb(null, stream);
}, function (err) {
var error;
// coerce into an error object since FF gives us a string
// there are only two valid names according to the spec
// we coerce all non-denied to "constraint not satisfied".
if (typeof err === 'string') {
error = new Error('NavigatorUserMediaError');
if (err === denied) {
error.name = denied;
} else {
error.name = notSatified;
}
} else {
// if we get an error object make sure '.name' property is set
// according to spec: http://dev.w3.org/2011/webrtc/editor/getusermedia.html#navigatorusermediaerror-and-navigatorusermediaerrorcallback
error = err;
if (!error.name) {
// this is likely chrome which
// sets a property called "ERROR_DENIED" on the error object
// if so we make sure to set a name
if (error[denied]) {
err.name = denied;
} else {
err.name = notSatified;
}
}
}
cb(error);
});
};
},{}],12:[function(require,module,exports){
var WildEmitter = require('wildemitter');
function getMaxVolume (analyser, fftBins) {
var maxVolume = -Infinity;
analyser.getFloatFrequencyData(fftBins);
for(var i=0, ii=fftBins.length; i < ii; i++) {
if (fftBins[i] > maxVolume && fftBins[i] < 0) {
maxVolume = fftBins[i];
}
};
return maxVolume;
}
module.exports = function(stream, options) {
var harker = new WildEmitter();
// make it not break in non-supported browsers
if (!window.webkitAudioContext) return harker;
//Config
var options = options || {},
smoothing = (options.smoothing || 0.5),
interval = (options.interval || 100),
threshold = options.threshold,
play = options.play;
//Setup Audio Context
var audioContext = new webkitAudioContext();
var sourceNode, fftBins, analyser;
analyser = audioContext.createAnalyser();
analyser.fftSize = 512;
analyser.smoothingTimeConstant = smoothing;
fftBins = new Float32Array(analyser.fftSize);
if (stream.jquery) stream = stream[0];
if (stream instanceof HTMLAudioElement) {
//Audio Tag
sourceNode = audioContext.createMediaElementSource(stream);
if (typeof play === 'undefined') play = true;
threshold = threshold || -65;
} else {
//WebRTC Stream
sourceNode = audioContext.createMediaStreamSource(stream);
threshold = threshold || -45;
}
sourceNode.connect(analyser);
if (play) analyser.connect(audioContext.destination);
harker.speaking = false;
harker.setThreshold = function(t) {
threshold = t;
};
harker.setInterval = function(i) {
interval = i;
};
// Poll the analyser node to determine if speaking
// and emit events if changed
var looper = function() {
setTimeout(function() {
var currentVolume = getMaxVolume(analyser, fftBins);
harker.emit('volume_change', currentVolume, threshold);
if (currentVolume > threshold) {
if (!harker.speaking) {
harker.speaking = true;
harker.emit('speaking');
}
} else {
if (harker.speaking) {
harker.speaking = false;
harker.emit('stopped_speaking');
}
}
looper();
}, interval);
};
looper();
return harker;
}
},{"wildemitter":24}],13:[function(require,module,exports){
var _ = require('underscore');
var webrtc = require('webrtcsupport');
var PeerConnection = require('rtcpeerconnection');
var SJJ = require('sdp-jingle-json');
function JinglePeerConnection(config, constraints) {
this.sid = '';
this.sdpSessId = Date.now();
this.isInitiator = true;
this.localDescription = {contents: []};
this.remoteDescription = {contents: []};
this.iceConfigs = {};
PeerConnection.call(this, config, constraints);
}
JinglePeerConnection.prototype = Object.create(PeerConnection.prototype, {
constructor: {
value: JinglePeerConnection
}
});
// Generate and emit an offer with the given constraints
JinglePeerConnection.prototype.offer = function (constraints, cb) {
var self = this;
var hasConstraints = arguments.length === 2;
var mediaConstraints = hasConstraints ? constraints : {
mandatory: {
OfferToReceiveAudio: true,
OfferToReceiveVideo: true
}
};
var callback = hasConstraints ? cb : constraints;
// Actually generate the offer
this.pc.createOffer(
function (offer) {
offer.sdp = self._applySdpHack(offer.sdp);
self.pc.setLocalDescription(offer);
var json = SJJ.toSessionJSON(offer.sdp, self.isInitiator ? 'initiator' : 'responder');
json.sid = this.sid;
self.localDescription = json;
// Save ICE credentials
_.each(json.contents, function (content) {
if ((content.transport || {}).ufrag) {
self.iceConfigs[content.name] = {
ufrag: (content.transport || {}).ufrag,
pwd: (content.transport || {}).pwd
};
}
});
var expandedOffer = {
type: 'offer',
sdp: offer.sdp,
json: json
};
self.emit('offer', expandedOffer);
if (callback) callback(null, expandedOffer);
},
function (err) {
self.emit('error', err);
if (callback) callback(err);
},
mediaConstraints
);
};
// Process an answer
PeerConnection.prototype.handleAnswer = function (answer, cb) {
cb = cb || function () {};
var self = this;
answer.sdp = SJJ.toSessionSDP(answer.json, this.sdpSessId);
self.remoteDescription = answer.json;
this.pc.setRemoteDescription(
new webrtc.SessionDescription(answer),
function () {
cb(null);
},
function (err) {
cb(err);
}
);
};
// Internal code sharing for various types of answer methods
JinglePeerConnection.prototype._answer = function (offer, constraints, cb) {
cb = cb || function () {};
var self = this;
offer.sdp = SJJ.toSessionSDP(offer.json, self.sdpSessId);
self.remoteDescription = offer.json;
this.pc.setRemoteDescription(new webrtc.SessionDescription(offer), function () {
self.pc.createAnswer(
function (answer) {
answer.sdp = self._applySdpHack(answer.sdp);
self.pc.setLocalDescription(answer);
var json = SJJ.toSessionJSON(answer.sdp);
json.sid = self.sid;
self.localDescription = json;
var expandedAnswer = {
type: 'answer',
sdp: answer.sdp,
json: json
};
self.emit('answer', expandedAnswer);
if (cb) cb(null, expandedAnswer);
}, function (err) {
self.emit('error', err);
if (cb) cb(err);
},
constraints
);
}, function (err) {
cb(err);
});
};
// Init and add ice candidate object with correct constructor
JinglePeerConnection.prototype.processIce = function (update, cb) {
cb = cb || function () {};
var self = this;
var contentNames = _.map(this.remoteDescription.contents, function (content) {
return content.name;
});
var contents = update.contents || [];
contents.forEach(function (content) {
var transport = content.transport || {};
var candidates = transport.candidates || [];
var mline = contentNames.indexOf(content.name);
var mid = content.name;
candidates.forEach(function (candidate) {
var iceCandidate = SJJ.toCandidateSDP(candidate) + '\r\n';
var iceData = {
candidate: iceCandidate,
sdpMLineIndex: mline,
sdpMid: mid
};
self.pc.addIceCandidate(new webrtc.IceCandidate(iceData));
});
});
cb();
};
// Internal method for emitting ice candidates on our peer object
JinglePeerConnection.prototype._onIce = function (event) {
var self = this;
if (event.candidate) {
var ice = event.candidate;
if (!self.iceConfigs[ice.sdpMid]) {
// Save ICE credentials
var json = SJJ.toSessionJSON(self.pc.localDescription.sdp, self.isInitiator ? 'initiator' : 'responder');
_.each(json.contents, function (content) {
if ((content.transport || {}).ufrag) {
self.iceConfigs[content.name] = {
ufrag: (content.transport || {}).ufrag,
pwd: (content.transport || {}).pwd
};
}
});
}
this.emit('ice', {
contents: [{
name: ice.sdpMid,
creator: self.isInitiator ? 'initiator' : 'responder',
transport: {
transType: 'iceUdp',
ufrag: self.iceConfigs[ice.sdpMid].ufrag,
pwd: self.iceConfigs[ice.sdpMid].pwd,
candidates: [
SJJ.toCandidateJSON(ice.candidate)
]
}
}]
});
} else {
this.emit('endOfCandidates');
}
};
module.exports = JinglePeerConnection;
},{"rtcpeerconnection":14,"sdp-jingle-json":18,"underscore":22,"webrtcsupport":23}],14:[function(require,module,exports){
var WildEmitter = require('wildemitter');
var webrtc = require('webrtcsupport');
function PeerConnection(config, constraints) {
var item;
this.pc = new webrtc.PeerConnection(config, constraints);
WildEmitter.call(this);
// proxy some events directly
this.pc.onremovestream = this.emit.bind(this, 'removeStream');
this.pc.onnegotiationneeded = this.emit.bind(this, 'negotiationNeeded');
this.pc.oniceconnectionstatechange = this.emit.bind(this, 'iceConnectionStateChange');
this.pc.onsignalingstatechange = this.emit.bind(this, 'signalingStateChange');
// handle incoming ice and data channel events
this.pc.onaddstream = this._onAddStream.bind(this);
this.pc.onicecandidate = this._onIce.bind(this);
this.pc.ondatachannel = this._onDataChannel.bind(this);
// whether to use SDP hack for faster data transfer
this.config = {
debug: false,
sdpHack: true
};
// apply our config
for (item in config) {
this.config[item] = config[item];
}
if (this.config.debug) {
this.on('*', function (eventName, event) {
var logger = config.logger || console;
logger.log('PeerConnection event:', arguments);
});
}
}
PeerConnection.prototype = Object.create(WildEmitter.prototype, {
constructor: {
value: PeerConnection
}
});
// Add a stream to the peer connection object
PeerConnection.prototype.addStream = function (stream) {
this.localStream = stream;
this.pc.addStream(stream);
};
// Init and add ice candidate object with correct constructor
PeerConnection.prototype.processIce = function (candidate) {
this.pc.addIceCandidate(new webrtc.IceCandidate(candidate));
};
// Generate and emit an offer with the given constraints
PeerConnection.prototype.offer = function (constraints, cb) {
var self = this;
var hasConstraints = arguments.length === 2;
var mediaConstraints = hasConstraints ? constraints : {
mandatory: {
OfferToReceiveAudio: true,
OfferToReceiveVideo: true
}
};
var callback = hasConstraints ? cb : constraints;
// Actually generate the offer
this.pc.createOffer(
function (offer) {
offer.sdp = self._applySdpHack(offer.sdp);
self.pc.setLocalDescription(offer);
self.emit('offer', offer);
if (callback) callback(null, offer);
},
function (err) {
self.emit('error', err);
if (callback) callback(err);
},
mediaConstraints
);
};
// Answer an offer with audio only
PeerConnection.prototype.answerAudioOnly = function (offer, cb) {
var mediaConstraints = {
mandatory: {
OfferToReceiveAudio: true,
OfferToReceiveVideo: false
}
};
this._answer(offer, mediaConstraints, cb);
};
// Answer an offer without offering to recieve
PeerConnection.prototype.answerBroadcastOnly = function (offer, cb) {
var mediaConstraints = {
mandatory: {
OfferToReceiveAudio: false,
OfferToReceiveVideo: false
}
};
this._answer(offer, mediaConstraints, cb);
};
// Answer an offer with given constraints default is audio/video
PeerConnection.prototype.answer = function (offer, constraints, cb) {
var self = this;
var hasConstraints = arguments.length === 3;
var callback = hasConstraints ? cb : constraints;
var mediaConstraints = hasConstraints ? constraints : {
mandatory: {
OfferToReceiveAudio: true,
OfferToReceiveVideo: true
}
};
this._answer(offer, mediaConstraints, callback);
};
// Process an answer
PeerConnection.prototype.handleAnswer = function (answer) {
this.pc.setRemoteDescription(new webrtc.SessionDescription(answer));
};
// Close the peer connection
PeerConnection.prototype.close = function () {
this.pc.close();
this.emit('close');
};
// Internal code sharing for various types of answer methods
PeerConnection.prototype._answer = function (offer, constraints, cb) {
var self = this;
this.pc.setRemoteDescription(new webrtc.SessionDescription(offer));
this.pc.createAnswer(
function (answer) {
answer.sdp = self._applySdpHack(answer.sdp);
self.pc.setLocalDescription(answer);
self.emit('answer', answer);
if (cb) cb(null, answer);
}, function (err) {
self.emit('error', err);
if (cb) cb(err);
},
constraints
);
};
// Internal method for emitting ice candidates on our peer object
PeerConnection.prototype._onIce = function (event) {
if (event.candidate) {
this.emit('ice', event.candidate);
} else {
this.emit('endOfCandidates');
}
};
// Internal method for processing a new data channel being added by the
// other peer.
PeerConnection.prototype._onDataChannel = function (event) {
this.emit('addChannel', event.channel);
};
// Internal handling of adding stream
PeerConnection.prototype._onAddStream = function (event) {
this.remoteStream = event.stream;
this.emit('addStream', event);
};
// SDP hack for increasing AS (application specific) data transfer speed allowed in chrome
PeerConnection.prototype._applySdpHack = function (sdp) {
if (!this.config.sdpHack) return sdp;
var parts = sdp.split('b=AS:30');
if (parts.length === 2) {
// increase max data transfer bandwidth to 100 Mbps
return parts[0] + 'b=AS:102400' + parts[1];
} else {
return sdp;
}
};
// Create a data channel spec reference:
// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannelInit
PeerConnection.prototype.createDataChannel = function (name, opts) {
opts || (opts = {});
var reliable = !!opts.reliable;
var protocol = opts.protocol || 'text/plain';
var negotiated = !!(opts.negotiated || opts.preset);
var settings;
var channel;
// firefox is a bit more finnicky
if (webrtc.prefix === 'moz') {
if (reliable) {
settings = {
protocol: protocol,
preset: negotiated,
stream: name
};
} else {
settings = {};
}
channel = this.pc.createDataChannel(name, settings);
channel.binaryType = 'blob';
} else {
if (reliable) {
settings = {
reliable: true
};
} else {
settings = {reliable: false};
}
channel = this.pc.createDataChannel(name, settings);
}
return channel;
};
module.exports = PeerConnection;
},{"webrtcsupport":23,"wildemitter":24}],15:[function(require,module,exports){
var support = require('webrtcsupport');
function GainController(stream) {
this.support = support.webAudio && support.mediaStream;
// set our starting value
this.gain = 1;
if (this.support) {
var context = this.context = new support.AudioContext();
this.microphone = context.createMediaStreamSource(stream);
this.gainFilter = context.createGain();
this.destination = context.createMediaStreamDestination();
this.outputStream = this.destination.stream;
this.microphone.connect(this.gainFilter);
this.gainFilter.connect(this.destination);
stream.removeTrack(stream.getAudioTracks()[0]);
stream.addTrack(this.outputStream.getAudioTracks()[0]);
}
this.stream = stream;
}
// setting
GainController.prototype.setGain = function (val) {
// check for support
if (!this.support) return;
this.gainFilter.gain.value = val;
this.gain = val;
};
GainController.prototype.getGain = function () {
return this.gain;
};
GainController.prototype.off = function () {
return this.setGain(0);
};
GainController.prototype.on = function () {
this.setGain(1);
};
module.exports = GainController;
},{"webrtcsupport":16}],16:[function(require,module,exports){
// created by @HenrikJoreteg
var PC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection || window.RTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
var prefix = function () {
if (window.mozRTCPeerConnection) {
return 'moz';
} else if (window.webkitRTCPeerConnection) {
return 'webkit';
}
}();
var MediaStream = window.webkitMediaStream || window.MediaStream;
var screenSharing = navigator.userAgent.match('Chrome') && parseInt(navigator.userAgent.match(/Chrome\/(.*) /)[1], 10) >= 26;
var AudioContext = window.webkitAudioContext || window.AudioContext;
// export support flags and constructors.prototype && PC
module.exports = {
support: !!PC,
dataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
prefix: prefix,
webAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
mediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
screenSharing: screenSharing,
AudioContext: AudioContext,
PeerConnection: PC,
SessionDescription: SessionDescription,
IceCandidate: IceCandidate
};
},{}],17:[function(require,module,exports){
var methods = "assert,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,time,timeEnd,trace,warn".split(",");
var l = methods.length;
var fn = function () {};
var mockconsole = {};
while (l--) {
mockconsole[methods[l]] = fn;
}
module.exports = mockconsole;
},{}],18:[function(require,module,exports){
var tosdp = require('./lib/tosdp');
var tojson = require('./lib/tojson');
exports.toSessionSDP = tosdp.toSessionSDP;
exports.toMediaSDP = tosdp.toMediaSDP;
exports.toCandidateSDP = tosdp.toCandidateSDP;
exports.toSessionJSON = tojson.toSessionJSON;
exports.toMediaJSON = tojson.toMediaJSON;
exports.toCandidateJSON = tojson.toCandidateJSON;
},{"./lib/tojson":20,"./lib/tosdp":21}],19:[function(require,module,exports){
exports.lines = function (sdp) {
return sdp.split('\r\n').filter(function (line) {
return line.length > 0;
});
};
exports.findLine = function (prefix, mediaLines, sessionLines) {
var prefixLength = prefix.length;
for (var i = 0; i < mediaLines.length; i++) {
if (mediaLines[i].substr(0, prefixLength) === prefix) {
return mediaLines[i];
}
}
// Continue searching in parent session section
if (!sessionLines) {
return false;
}
for (var j = 0; j < sessionLines.length; j++) {
if (sessionLines[j].substr(0, prefixLength) === prefix) {
return sessionLines[j];
}
}
return false;
};
exports.findLines = function (prefix, mediaLines, sessionLines) {
var results = [];
var prefixLength = prefix.length;
for (var i = 0; i < mediaLines.length; i++) {
if (mediaLines[i].substr(0, prefixLength) === prefix) {
results.push(mediaLines[i]);
}
}
if (results.length || !sessionLines) {
return results;
}
for (var j = 0; j < sessionLines.length; j++) {
if (sessionLines[j].substr(0, prefixLength) === prefix) {
results.push(sessionLines[j]);
}
}
return results;
};
exports.mline = function (line) {
var parts = line.substr(2).split(' ');
var parsed = {
media: parts[0],
port: parts[1],
proto: parts[2],
formats: []
};
for (var i = 3; i < parts.length; i++) {
if (parts[i]) {
parsed.formats.push(parts[i]);
}
}
return parsed;
};
exports.rtpmap = function (line) {
var parts = line.substr(9).split(' ');
var parsed = {
id: parts.shift()
};
parts = parts[0].split('/');
parsed.name = parts[0];
parsed.clockrate = parts[1];
parsed.channels = parts.length == 3 ? parts[2] : '1';
return parsed;
};
exports.fmtp = function (line) {
var kv, key, value;
var parts = line.substr(line.indexOf(' ') + 1).split(';');
var parsed = [];
for (var i = 0; i < parts.length; i++) {
kv = parts[i].split('=');
key = kv[0].trim();
value = kv[1];
if (key && value) {
parsed.push({key: key, value: value});
} else if (key) {
parsed.push({key: '', value: key});
}
}
return parsed;
};
exports.crypto = function (line) {
var parts = line.substr(9).split(' ');
var parsed = {
tag: parts[0],
cipherSuite: parts[1],
keyParams: parts[2],
sessionParams: parts.slice(3).join(' ')
};
return parsed;
};
exports.fingerprint = function (line) {
var parts = line.substr(14).split(' ');
return {
hash: parts[0],
value: parts[1]
};
};
exports.extmap = function (line) {
var parts = line.substr(9).split(' ');
var parsed = {};
var idpart = parts.shift();
var sp = idpart.indexOf('/');
if (sp >= 0) {
parsed.id = idpart.substr(0, sp);
parsed.senders = idpart.substr(sp);
} else {
parsed.id = idpart;
parsed.senders = 'sendrecv';
}
parsed.uri = parts.shift();
return parsed;
};
exports.rtcpfb = function (line) {
var parts = line.substr(10).split(' ');
var parsed = {};
parsed.id = parts.shift();
parsed.type = parts.shift();
if (parsed.type === 'trr-int') {
parsed.value = parts.shift();
} else {
parsed.subtype = parts.shift();
}
parsed.parameters = parts;
return parsed;
};
exports.candidate = function (line) {
var parts = line.substring(12).split(' ');
var candidate = {
foundation: parts[0],
component: parts[1],
protocol: parts[2].toLowerCase(),
priority: parts[3],
ip: parts[4],
port: parts[5],
// skip parts[6] == 'typ'
type: parts[7]
};
for (var i = 8; i < parts.length; i += 2) {
if (parts[i] === 'raddr') {
candidate.relAddr = parts[i + 1];
} else if (parts[i] === 'rport') {
candidate.relPort = parts[i + 1];
} else if (parts[i] === 'generation') {
candidate.generation = parts[i + 1];
}
}
candidate.network = '1';
return candidate;
};
exports.ssrc = function (lines) {
// http://tools.ietf.org/html/rfc5576
var parsed = [];
var perssrc = {};
var parts;
var ssrc;
for (var i = 0; i < lines.length; i++) {
parts = lines[i].substr(7).split(' ');
ssrc = parts.shift();
parts = parts.join(' ').split(':');
var attribute = parts.shift();
var value = parts.join(':') || null;
if (!perssrc[ssrc]) perssrc[ssrc] = {};
perssrc[ssrc][attribute] = value;
}
for (ssrc in perssrc) {
var item = perssrc[ssrc];
item.ssrc = ssrc;
parsed.push(item);
}
return parsed;
};
exports.grouping = function (lines) {
// http://tools.ietf.org/html/rfc5888
var parsed = [];
var parts;
for (var i = 0; i < lines.length; i++) {
parts = lines[i].substr(8).split(' ');
parsed.push({
semantics: parts.shift(),
contents: parts
});
}
return parsed;
};
},{}],20:[function(require,module,exports){
var parsers = require('./parsers');
var idCounter = Math.random();
exports.toSessionJSON = function (sdp, creator) {
// Divide the SDP into session and media sections.
var media = sdp.split('\r\nm=');
for (var i = 1; i < media.length; i++) {
media[i] = 'm=' + media[i];
if (i !== media.length - 1) {
media[i] += '\r\n';
}
}
var session = media.shift() + '\r\n';
var sessionLines = parsers.lines(session);
var parsed = {};
var contents = [];
media.forEach(function (m) {
contents.push(exports.toMediaJSON(m, session, creator));
});
parsed.contents = contents;
var groupLines = parsers.findLines('a=group:', sessionLines);
if (groupLines.length) {
parsed.groupings = parsers.grouping(groupLines);
}
return parsed;
};
exports.toMediaJSON = function (media, session, creator) {
var lines = parsers.lines(media);
var sessionLines = parsers.lines(session);
var mline = parsers.mline(lines[0]);
var content = {
creator: creator,
name: mline.media,
description: {
descType: 'rtp',
media: mline.media,
payloads: [],
encryption: [],
feedback: [],
headerExtensions: []
},
transport: {
transType: 'iceUdp',
candidates: [],
fingerprints: []
}
};
var desc = content.description;
var trans = content.transport;
var ssrc = parsers.findLine('a=ssrc:', lines);
if (ssrc) {
desc.ssrc = ssrc.substr(7).split(' ')[0];
}
// If we have a mid, use that for the content name instead.
var mid = parsers.findLine('a=mid:', lines);
if (mid) {
content.name = mid.substr(6);
}
if (parsers.findLine('a=sendrecv', lines, sessionLines)) {
content.senders = 'both';
} else if (parsers.findLine('a=sendonly', lines, sessionLines)) {
content.senders = 'initiator';
} else if (parsers.findLine('a=recvonly', lines, sessionLines)) {
content.senders = 'responder';
} else if (parsers.findLine('a=inactive', lines, sessionLines)) {
content.senders = 'none';
}
var rtpmapLines = parsers.findLines('a=rtpmap:', lines);
rtpmapLines.forEach(function (line) {
var payload = parsers.rtpmap(line);
payload.feedback = [];
var fmtpLines = parsers.findLines('a=fmtp:' + payload.id, lines);
fmtpLines.forEach(function (line) {
payload.parameters = parsers.fmtp(line);
});
var fbLines = parsers.findLines('a=rtcp-fb:' + payload.id, lines);
fbLines.forEach(function (line) {
payload.feedback.push(parsers.rtcpfb(line));
});
desc.payloads.push(payload);
});
var cryptoLines = parsers.findLines('a=crypto:', lines, sessionLines);
cryptoLines.forEach(function (line) {
desc.encryption.push(parsers.crypto(line));
});
if (parsers.findLine('a=rtcp-mux', lines)) {
desc.mux = true;
}
var fbLines = parsers.findLines('a=rtcp-fb:*', lines);
fbLines.forEach(function (line) {
desc.feedback.push(parsers.rtcpfb(line));
});
var extLines = parsers.findLines('a=extmap:', lines);
extLines.forEach(function (line) {
var ext = parsers.extmap(line);
var senders = {
sendonly: 'responder',
recvonly: 'initiator',
sendrecv: 'both',
inactive: 'none'
};
ext.senders = senders[ext.senders];
desc.headerExtensions.push(ext);
});
var ssrcLines = parsers.findLines('a=ssrc:', lines);
if (ssrcLines.length) {
desc.ssrcs = parsers.ssrc(ssrcLines);
}
var fingerprintLines = parsers.findLines('a=fingerprint:', lines, sessionLines);
fingerprintLines.forEach(function (line) {
trans.fingerprints.push(parsers.fingerprint(line));
});
var ufragLine = parsers.findLine('a=ice-ufrag:', lines, sessionLines);
var pwdLine = parsers.findLine('a=ice-pwd:', lines, sessionLines);
if (ufragLine && pwdLine) {
trans.ufrag = ufragLine.substr(12);
trans.pwd = pwdLine.substr(10);
trans.candidates = [];
var candidateLines = parsers.findLines('a=candidate:', lines, sessionLines);
candidateLines.forEach(function (line) {
trans.candidates.push(exports.toCandidateJSON(line));
});
}
return content;
};
exports.toCandidateJSON = function (line) {
var candidate = parsers.candidate(line.split('\r\n')[0]);
candidate.id = (idCounter++).toString(36).substr(0, 12);
return candidate;
};
},{"./parsers":19}],21:[function(require,module,exports){
var senders = {
'initiator': 'sendonly',
'responder': 'recvonly',
'both': 'sendrecv',
'none': 'inactive',
'sendonly': 'initator',
'recvonly': 'responder',
'sendrecv': 'both',
'inactive': 'none'
};
exports.toSessionSDP = function (session, sid) {
var sdp = [
'v=0',
'o=- ' + (sid || session.sid || Date.now()) + ' ' + Date.now() + ' IN IP4 0.0.0.0',
's=-',
't=0 0'
];
var groupings = session.groupings || [];
groupings.forEach(function (grouping) {
sdp.push('a=group:' + grouping.semantics + ' ' + grouping.contents.join(' '));
});
var contents = session.contents || [];
contents.forEach(function (content) {
sdp.push(exports.toMediaSDP(content));
});
return sdp.join('\r\n') + '\r\n';
};
exports.toMediaSDP = function (content) {
var sdp = [];
var desc = content.description;
var transport = content.transport;
var payloads = desc.payloads || [];
var fingerprints = (transport && transport.fingerprints) || [];
var mline = [desc.media, '1'];
if ((desc.encryption && desc.encryption.length > 0) || (fingerprints.length > 0)) {
mline.push('RTP/SAVPF');
} else {
mline.push('RTP/AVPF');
}
payloads.forEach(function (payload) {
mline.push(payload.id);
});
sdp.push('m=' + mline.join(' '));
sdp.push('c=IN IP4 0.0.0.0');
sdp.push('a=rtcp:1 IN IP4 0.0.0.0');
if (transport) {
if (transport.ufrag) {
sdp.push('a=ice-ufrag:' + transport.ufrag);
}
if (transport.pwd) {
sdp.push('a=ice-pwd:' + transport.pwd);
}
fingerprints.forEach(function (fingerprint) {
sdp.push('a=fingerprint:' + fingerprint.hash + ' ' + fingerprint.value);
});
}
sdp.push('a=' + (senders[content.senders] || 'sendrecv'));
sdp.push('a=mid:' + content.name);
if (desc.mux) {
sdp.push('a=rtcp-mux');
}
var encryption = desc.encryption || [];
encryption.forEach(function (crypto) {
sdp.push('a=crypto:' + crypto.tag + ' ' + crypto.cipherSuite + ' ' + crypto.keyParams + (crypto.sessionParams ? ' ' + crypto.sessionParams : ''));
});
payloads.forEach(function (payload) {
var rtpmap = 'a=rtpmap:' + payload.id + ' ' + payload.name + '/' + payload.clockrate;
if (payload.channels && payload.channels != '1') {
rtpmap += '/' + payload.channels;
}
sdp.push(rtpmap);
if (payload.parameters && payload.parameters.length) {
var fmtp = ['a=fmtp:' + payload.id];
payload.parameters.forEach(function (param) {
fmtp.push((param.key ? param.key + '=' : '') + param.value);
});
sdp.push(fmtp.join(' '));
}
if (payload.feedback) {
payload.feedback.forEach(function (fb) {
if (fb.type === 'trr-int') {
sdp.push('a=rtcp-fb:' + payload.id + ' trr-int ' + fb.value ? fb.value : '0');
} else {
sdp.push('a=rtcp-fb:' + payload.id + ' ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
}
});
}
});
if (desc.feedback) {
desc.feedback.forEach(function (fb) {
if (fb.type === 'trr-int') {
sdp.push('a=rtcp-fb:* trr-int ' + fb.value ? fb.value : '0');
} else {
sdp.push('a=rtcp-fb:* ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
}
});
}
var hdrExts = desc.headerExtensions || [];
hdrExts.forEach(function (hdr) {
sdp.push('a=extmap:' + hdr.id + (hdr.senders ? '/' + senders[hdr.senders] : '') + ' ' + hdr.uri);
});
var ssrcs = desc.ssrcs || [];
ssrcs.forEach(function (ssrc) {
for (var attribute in ssrc) {
if (attribute == 'ssrc') continue;
sdp.push('a=ssrc:' + (ssrc.ssrc || desc.ssrc) + ' ' + attribute + (ssrc[attribute] ? (':' + ssrc[attribute]) : ''));
}
});
var candidates = transport.candidates || [];
candidates.forEach(function (candidate) {
sdp.push(exports.toCandidateSDP(candidate));
});
return sdp.join('\r\n');
};
exports.toCandidateSDP = function (candidate) {
var sdp = [];
sdp.push(candidate.foundation);
sdp.push(candidate.component);
sdp.push(candidate.protocol);
sdp.push(candidate.priority);
sdp.push(candidate.ip);
sdp.push(candidate.port);
var type = candidate.type;
sdp.push('typ');
sdp.push(type);
if (type === 'srflx' || type === 'prflx' || type === 'relay') {
if (candidate.relAddr && candidate.relPort) {
sdp.push('raddr');
sdp.push(candidate.relAddr);
sdp.push('rport');
sdp.push(candidate.relPort);
}
}
sdp.push('generation');
sdp.push(candidate.generation || '0');
return 'a=candidate:' + sdp.join(' ');
};
},{}],22:[function(require,module,exports){
// Underscore.js 1.5.2
// http://underscorejs.org
// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
// Underscore may be freely distributed under the MIT license.
(function() {
// Baseline setup
// --------------
// Establish the root object, `window` in the browser, or `exports` on the server.
var root = this;
// Save the previous value of the `_` variable.
var previousUnderscore = root._;
// Establish the object that gets returned to break out of a loop iteration.
var breaker = {};
// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
// Create quick reference variables for speed access to core prototypes.
var
push = ArrayProto.push,
slice = ArrayProto.slice,
concat = ArrayProto.concat,
toString = ObjProto.toString,
hasOwnProperty = ObjProto.hasOwnProperty;
// All **ECMAScript 5** native function implementations that we hope to use
// are declared here.
var
nativeForEach = ArrayProto.forEach,
nativeMap = ArrayProto.map,
nativeReduce = ArrayProto.reduce,
nativeReduceRight = ArrayProto.reduceRight,
nativeFilter = ArrayProto.filter,
nativeEvery = ArrayProto.every,
nativeSome = ArrayProto.some,
nativeIndexOf = ArrayProto.indexOf,
nativeLastIndexOf = ArrayProto.lastIndexOf,
nativeIsArray = Array.isArray,
nativeKeys = Object.keys,
nativeBind = FuncProto.bind;
// Create a safe reference to the Underscore object for use below.
var _ = function(obj) {
if (obj instanceof _) return obj;
if (!(this instanceof _)) return new _(obj);
this._wrapped = obj;
};
// Export the Underscore object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, add `_` as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
if (typeof module !== 'undefined' && module.exports) {
exports = module.exports = _;
}
exports._ = _;
} else {
root._ = _;
}
// Current version.
_.VERSION = '1.5.2';
// Collection Functions
// --------------------
// The cornerstone, an `each` implementation, aka `forEach`.
// Handles objects with the built-in `forEach`, arrays, and raw objects.
// Delegates to **ECMAScript 5**'s native `forEach` if available.
var each = _.each = _.forEach = function(obj, iterator, context) {
if (obj == null) return;
if (nativeForEach && obj.forEach === nativeForEach) {
obj.forEach(iterator, context);
} else if (obj.length === +obj.length) {
for (var i = 0, length = obj.length; i < length; i++) {
if (iterator.call(context, obj[i], i, obj) === breaker) return;
}
} else {
var keys = _.keys(obj);
for (var i = 0, length = keys.length; i < length; i++) {
if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
}
}
};
// Return the results of applying the iterator to each element.
// Delegates to **ECMAScript 5**'s native `map` if available.
_.map = _.collect = function(obj, iterator, context) {
var results = [];
if (obj == null) return results;
if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
each(obj, function(value, index, list) {
results.push(iterator.call(context, value, index, list));
});
return results;
};
var reduceError = 'Reduce of empty array with no initial value';
// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
var initial = arguments.length > 2;
if (obj == null) obj = [];
if (nativeReduce && obj.reduce === nativeReduce) {
if (context) iterator = _.bind(iterator, context);
return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
}
each(obj, function(value, index, list) {
if (!initial) {
memo = value;
initial = true;
} else {
memo = iterator.call(context, memo, value, index, list);
}
});
if (!initial) throw new TypeError(reduceError);
return memo;
};
// The right-associative version of reduce, also known as `foldr`.
// Delegates to **ECMAScript 5**'s native `reduceRight` if available.
_.reduceRight = _.foldr = function(obj, iterator, memo, context) {
var initial = arguments.length > 2;
if (obj == null) obj = [];
if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
if (context) iterator = _.bind(iterator, context);
return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
}
var length = obj.length;
if (length !== +length) {
var keys = _.keys(obj);
length = keys.length;
}
each(obj, function(value, index, list) {
index = keys ? keys[--length] : --length;
if (!initial) {
memo = obj[index];
initial = true;
} else {
memo = iterator.call(context, memo, obj[index], index, list);
}
});
if (!initial) throw new TypeError(reduceError);
return memo;
};
// Return the first value which passes a truth test. Aliased as `detect`.
_.find = _.detect = function(obj, iterator, context) {
var result;
any(obj, function(value, index, list) {
if (iterator.call(context, value, index, list)) {
result = value;
return true;
}
});
return result;
};
// Return all the elements that pass a truth test.
// Delegates to **ECMAScript 5**'s native `filter` if available.
// Aliased as `select`.
_.filter = _.select = function(obj, iterator, context) {
var results = [];
if (obj == null) return results;
if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
each(obj, function(value, index, list) {
if (iterator.call(context, value, index, list)) results.push(value);
});
return results;
};
// Return all the elements for which a truth test fails.
_.reject = function(obj, iterator, context) {
return _.filter(obj, function(value, index, list) {
return !iterator.call(context, value, index, list);
}, context);
};
// Determine whether all of the elements match a truth test.
// Delegates to **ECMAScript 5**'s native `every` if available.
// Aliased as `all`.
_.every = _.all = function(obj, iterator, context) {
iterator || (iterator = _.identity);
var result = true;
if (obj == null) return result;
if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
each(obj, function(value, index, list) {
if (!(result = result && iterator.call(context, value, index, list))) return breaker;
});
return !!result;
};
// Determine if at least one element in the object matches a truth test.
// Delegates to **ECMAScript 5**'s native `some` if available.
// Aliased as `any`.
var any = _.some = _.any = function(obj, iterator, context) {
iterator || (iterator = _.identity);
var result = false;
if (obj == null) return result;
if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
each(obj, function(value, index, list) {
if (result || (result = iterator.call(context, value, index, list))) return breaker;
});
return !!result;
};
// Determine if the array or object contains a given value (using `===`).
// Aliased as `include`.
_.contains = _.include = function(obj, target) {
if (obj == null) return false;
if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
return any(obj, function(value) {
return value === target;
});
};
// Invoke a method (with arguments) on every item in a collection.
_.invoke = function(obj, method) {
var args = slice.call(arguments, 2);
var isFunc = _.isFunction(method);
return _.map(obj, function(value) {
return (isFunc ? method : value[method]).apply(value, args);
});
};
// Convenience version of a common use case of `map`: fetching a property.
_.pluck = function(obj, key) {
return _.map(obj, function(value){ return value[key]; });
};
// Convenience version of a common use case of `filter`: selecting only objects
// containing specific `key:value` pairs.
_.where = function(obj, attrs, first) {
if (_.isEmpty(attrs)) return first ? void 0 : [];
return _[first ? 'find' : 'filter'](obj, function(value) {
for (var key in attrs) {
if (attrs[key] !== value[key]) return false;
}
return true;
});
};
// Convenience version of a common use case of `find`: getting the first object
// containing specific `key:value` pairs.
_.findWhere = function(obj, attrs) {
return _.where(obj, attrs, true);
};
// Return the maximum element or (element-based computation).
// Can't optimize arrays of integers longer than 65,535 elements.
// See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
_.max = function(obj, iterator, context) {
if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
return Math.max.apply(Math, obj);
}
if (!iterator && _.isEmpty(obj)) return -Infinity;
var result = {computed : -Infinity, value: -Infinity};
each(obj, function(value, index, list) {
var computed = iterator ? iterator.call(context, value, index, list) : value;
computed > result.computed && (result = {value : value, computed : computed});
});
return result.value;
};
// Return the minimum element (or element-based computation).
_.min = function(obj, iterator, context) {
if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
return Math.min.apply(Math, obj);
}
if (!iterator && _.isEmpty(obj)) return Infinity;
var result = {computed : Infinity, value: Infinity};
each(obj, function(value, index, list) {
var computed = iterator ? iterator.call(context, value, index, list) : value;
computed < result.computed && (result = {value : value, computed : computed});
});
return result.value;
};
// Shuffle an array, using the modern version of the
// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
_.shuffle = function(obj) {
var rand;
var index = 0;
var shuffled = [];
each(obj, function(value) {
rand = _.random(index++);
shuffled[index - 1] = shuffled[rand];
shuffled[rand] = value;
});
return shuffled;
};
// Sample **n** random values from an array.
// If **n** is not specified, returns a single random element from the array.
// The internal `guard` argument allows it to work with `map`.
_.sample = function(obj, n, guard) {
if (arguments.length < 2 || guard) {
return obj[_.random(obj.length - 1)];
}
return _.shuffle(obj).slice(0, Math.max(0, n));
};
// An internal function to generate lookup iterators.
var lookupIterator = function(value) {
return _.isFunction(value) ? value : function(obj){ return obj[value]; };
};
// Sort the object's values by a criterion produced by an iterator.
_.sortBy = function(obj, value, context) {
var iterator = lookupIterator(value);
return _.pluck(_.map(obj, function(value, index, list) {
return {
value: value,
index: index,
criteria: iterator.call(context, value, index, list)
};
}).sort(function(left, right) {
var a = left.criteria;
var b = right.criteria;
if (a !== b) {
if (a > b || a === void 0) return 1;
if (a < b || b === void 0) return -1;
}
return left.index - right.index;
}), 'value');
};
// An internal function used for aggregate "group by" operations.
var group = function(behavior) {
return function(obj, value, context) {
var result = {};
var iterator = value == null ? _.identity : lookupIterator(value);
each(obj, function(value, index) {
var key = iterator.call(context, value, index, obj);
behavior(result, key, value);
});
return result;
};
};
// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
_.groupBy = group(function(result, key, value) {
(_.has(result, key) ? result[key] : (result[key] = [])).push(value);
});
// Indexes the object's values by a criterion, similar to `groupBy`, but for
// when you know that your index values will be unique.
_.indexBy = group(function(result, key, value) {
result[key] = value;
});
// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
_.countBy = group(function(result, key) {
_.has(result, key) ? result[key]++ : result[key] = 1;
});
// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
_.sortedIndex = function(array, obj, iterator, context) {
iterator = iterator == null ? _.identity : lookupIterator(iterator);
var value = iterator.call(context, obj);
var low = 0, high = array.length;
while (low < high) {
var mid = (low + high) >>> 1;
iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
}
return low;
};
// Safely create a real, live array from anything iterable.
_.toArray = function(obj) {
if (!obj) return [];
if (_.isArray(obj)) return slice.call(obj);
if (obj.length === +obj.length) return _.map(obj, _.identity);
return _.values(obj);
};
// Return the number of elements in an object.
_.size = function(obj) {
if (obj == null) return 0;
return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
};
// Array Functions
// ---------------
// Get the first element of an array. Passing **n** will return the first N
// values in the array. Aliased as `head` and `take`. The **guard** check
// allows it to work with `_.map`.
_.first = _.head = _.take = function(array, n, guard) {
if (array == null) return void 0;
return (n == null) || guard ? array[0] : slice.call(array, 0, n);
};
// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N. The **guard** check allows it to work with
// `_.map`.
_.initial = function(array, n, guard) {
return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
};
// Get the last element of an array. Passing **n** will return the last N
// values in the array. The **guard** check allows it to work with `_.map`.
_.last = function(array, n, guard) {
if (array == null) return void 0;
if ((n == null) || guard) {
return array[array.length - 1];
} else {
return slice.call(array, Math.max(array.length - n, 0));
}
};
// Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
// Especially useful on the arguments object. Passing an **n** will return
// the rest N values in the array. The **guard**
// check allows it to work with `_.map`.
_.rest = _.tail = _.drop = function(array, n, guard) {
return slice.call(array, (n == null) || guard ? 1 : n);
};
// Trim out all falsy values from an array.
_.compact = function(array) {
return _.filter(array, _.identity);
};
// Internal implementation of a recursive `flatten` function.
var flatten = function(input, shallow, output) {
if (shallow && _.every(input, _.isArray)) {
return concat.apply(output, input);
}
each(input, function(value) {
if (_.isArray(value) || _.isArguments(value)) {
shallow ? push.apply(output, value) : flatten(value, shallow, output);
} else {
output.push(value);
}
});
return output;
};
// Flatten out an array, either recursively (by default), or just one level.
_.flatten = function(array, shallow) {
return flatten(array, shallow, []);
};
// Return a version of the array that does not contain the specified value(s).
_.without = function(array) {
return _.difference(array, slice.call(arguments, 1));
};
// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// Aliased as `unique`.
_.uniq = _.unique = function(array, isSorted, iterator, context) {
if (_.isFunction(isSorted)) {
context = iterator;
iterator = isSorted;
isSorted = false;
}
var initial = iterator ? _.map(array, iterator, context) : array;
var results = [];
var seen = [];
each(initial, function(value, index) {
if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
seen.push(value);
results.push(array[index]);
}
});
return results;
};
// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
_.union = function() {
return _.uniq(_.flatten(arguments, true));
};
// Produce an array that contains every item shared between all the
// passed-in arrays.
_.intersection = function(array) {
var rest = slice.call(arguments, 1);
return _.filter(_.uniq(array), function(item) {
return _.every(rest, function(other) {
return _.indexOf(other, item) >= 0;
});
});
};
// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
_.difference = function(array) {
var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
return _.filter(array, function(value){ return !_.contains(rest, value); });
};
// Zip together multiple lists into a single array -- elements that share
// an index go together.
_.zip = function() {
var length = _.max(_.pluck(arguments, "length").concat(0));
var results = new Array(length);
for (var i = 0; i < length; i++) {
results[i] = _.pluck(arguments, '' + i);
}
return results;
};
// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values.
_.object = function(list, values) {
if (list == null) return {};
var result = {};
for (var i = 0, length = list.length; i < length; i++) {
if (values) {
result[list[i]] = values[i];
} else {
result[list[i][0]] = list[i][1];
}
}
return result;
};
// If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
// we need this function. Return the position of the first occurrence of an
// item in an array, or -1 if the item is not included in the array.
// Delegates to **ECMAScript 5**'s native `indexOf` if available.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
_.indexOf = function(array, item, isSorted) {
if (array == null) return -1;
var i = 0, length = array.length;
if (isSorted) {
if (typeof isSorted == 'number') {
i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
} else {
i = _.sortedIndex(array, item);
return array[i] === item ? i : -1;
}
}
if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
for (; i < length; i++) if (array[i] === item) return i;
return -1;
};
// Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
_.lastIndexOf = function(array, item, from) {
if (array == null) return -1;
var hasIndex = from != null;
if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
}
var i = (hasIndex ? from : array.length);
while (i--) if (array[i] === item) return i;
return -1;
};
// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](http://docs.python.org/library/functions.html#range).
_.range = function(start, stop, step) {
if (arguments.length <= 1) {
stop = start || 0;
start = 0;
}
step = arguments[2] || 1;
var length = Math.max(Math.ceil((stop - start) / step), 0);
var idx = 0;
var range = new Array(length);
while(idx < length) {
range[idx++] = start;
start += step;
}
return range;
};
// Function (ahem) Functions
// ------------------
// Reusable constructor function for prototype setting.
var ctor = function(){};
// Create a function bound to a given object (assigning `this`, and arguments,
// optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
// available.
_.bind = function(func, context) {
var args, bound;
if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
if (!_.isFunction(func)) throw new TypeError;
args = slice.call(arguments, 2);
return bound = function() {
if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
ctor.prototype = func.prototype;
var self = new ctor;
ctor.prototype = null;
var result = func.apply(self, args.concat(slice.call(arguments)));
if (Object(result) === result) return result;
return self;
};
};
// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context.
_.partial = function(func) {
var args = slice.call(arguments, 1);
return function() {
return func.apply(this, args.concat(slice.call(arguments)));
};
};
// Bind all of an object's methods to that object. Useful for ensuring that
// all callbacks defined on an object belong to it.
_.bindAll = function(obj) {
var funcs = slice.call(arguments, 1);
if (funcs.length === 0) throw new Error("bindAll must be passed function names");
each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
return obj;
};
// Memoize an expensive function by storing its results.
_.memoize = function(func, hasher) {
var memo = {};
hasher || (hasher = _.identity);
return function() {
var key = hasher.apply(this, arguments);
return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
};
};
// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
_.delay = function(func, wait) {
var args = slice.call(arguments, 2);
return setTimeout(function(){ return func.apply(null, args); }, wait);
};
// Defers a function, scheduling it to run after the current call stack has
// cleared.
_.defer = function(func) {
return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
};
// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
_.throttle = function(func, wait, options) {
var context, args, result;
var timeout = null;
var previous = 0;
options || (options = {});
var later = function() {
previous = options.leading === false ? 0 : new Date;
timeout = null;
result = func.apply(context, args);
};
return function() {
var now = new Date;
if (!previous && options.leading === false) previous = now;
var remaining = wait - (now - previous);
context = this;
args = arguments;
if (remaining <= 0) {
clearTimeout(timeout);
timeout = null;
previous = now;
result = func.apply(context, args);
} else if (!timeout && options.trailing !== false) {
timeout = setTimeout(later, remaining);
}
return result;
};
};
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
_.debounce = function(func, wait, immediate) {
var timeout, args, context, timestamp, result;
return function() {
context = this;
args = arguments;
timestamp = new Date();
var later = function() {
var last = (new Date()) - timestamp;
if (last < wait) {
timeout = setTimeout(later, wait - last);
} else {
timeout = null;
if (!immediate) result = func.apply(context, args);
}
};
var callNow = immediate && !timeout;
if (!timeout) {
timeout = setTimeout(later, wait);
}
if (callNow) result = func.apply(context, args);
return result;
};
};
// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
_.once = function(func) {
var ran = false, memo;
return function() {
if (ran) return memo;
ran = true;
memo = func.apply(this, arguments);
func = null;
return memo;
};
};
// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
_.wrap = function(func, wrapper) {
return function() {
var args = [func];
push.apply(args, arguments);
return wrapper.apply(this, args);
};
};
// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
_.compose = function() {
var funcs = arguments;
return function() {
var args = arguments;
for (var i = funcs.length - 1; i >= 0; i--) {
args = [funcs[i].apply(this, args)];
}
return args[0];
};
};
// Returns a function that will only be executed after being called N times.
_.after = function(times, func) {
return function() {
if (--times < 1) {
return func.apply(this, arguments);
}
};
};
// Object Functions
// ----------------
// Retrieve the names of an object's properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`
_.keys = nativeKeys || function(obj) {
if (obj !== Object(obj)) throw new TypeError('Invalid object');
var keys = [];
for (var key in obj) if (_.has(obj, key)) keys.push(key);
return keys;
};
// Retrieve the values of an object's properties.
_.values = function(obj) {
var keys = _.keys(obj);
var length = keys.length;
var values = new Array(length);
for (var i = 0; i < length; i++) {
values[i] = obj[keys[i]];
}
return values;
};
// Convert an object into a list of `[key, value]` pairs.
_.pairs = function(obj) {
var keys = _.keys(obj);
var length = keys.length;
var pairs = new Array(length);
for (var i = 0; i < length; i++) {
pairs[i] = [keys[i], obj[keys[i]]];
}
return pairs;
};
// Invert the keys and values of an object. The values must be serializable.
_.invert = function(obj) {
var result = {};
var keys = _.keys(obj);
for (var i = 0, length = keys.length; i < length; i++) {
result[obj[keys[i]]] = keys[i];
}
return result;
};
// Return a sorted list of the function names available on the object.
// Aliased as `methods`
_.functions = _.methods = function(obj) {
var names = [];
for (var key in obj) {
if (_.isFunction(obj[key])) names.push(key);
}
return names.sort();
};
// Extend a given object with all the properties in passed-in object(s).
_.extend = function(obj) {
each(slice.call(arguments, 1), function(source) {
if (source) {
for (var prop in source) {
obj[prop] = source[prop];
}
}
});
return obj;
};
// Return a copy of the object only containing the whitelisted properties.
_.pick = function(obj) {
var copy = {};
var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
each(keys, function(key) {
if (key in obj) copy[key] = obj[key];
});
return copy;
};
// Return a copy of the object without the blacklisted properties.
_.omit = function(obj) {
var copy = {};
var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
for (var key in obj) {
if (!_.contains(keys, key)) copy[key] = obj[key];
}
return copy;
};
// Fill in a given object with default properties.
_.defaults = function(obj) {
each(slice.call(arguments, 1), function(source) {
if (source) {
for (var prop in source) {
if (obj[prop] === void 0) obj[prop] = source[prop];
}
}
});
return obj;
};
// Create a (shallow-cloned) duplicate of an object.
_.clone = function(obj) {
if (!_.isObject(obj)) return obj;
return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
};
// Invokes interceptor with the obj, and then returns obj.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
_.tap = function(obj, interceptor) {
interceptor(obj);
return obj;
};
// Internal recursive comparison function for `isEqual`.
var eq = function(a, b, aStack, bStack) {
// Identical objects are equal. `0 === -0`, but they aren't identical.
// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
if (a === b) return a !== 0 || 1 / a == 1 / b;
// A strict comparison is necessary because `null == undefined`.
if (a == null || b == null) return a === b;
// Unwrap any wrapped objects.
if (a instanceof _) a = a._wrapped;
if (b instanceof _) b = b._wrapped;
// Compare `[[Class]]` names.
var className = toString.call(a);
if (className != toString.call(b)) return false;
switch (className) {
// Strings, numbers, dates, and booleans are compared by value.
case '[object String]':
// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
// equivalent to `new String("5")`.
return a == String(b);
case '[object Number]':
// `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
// other numeric values.
return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
case '[object Date]':
case '[object Boolean]':
// Coerce dates and booleans to numeric primitive values. Dates are compared by their
// millisecond representations. Note that invalid dates with millisecond representations
// of `NaN` are not equivalent.
return +a == +b;
// RegExps are compared by their source patterns and flags.
case '[object RegExp]':
return a.source == b.source &&
a.global == b.global &&
a.multiline == b.multiline &&
a.ignoreCase == b.ignoreCase;
}
if (typeof a != 'object' || typeof b != 'object') return false;
// Assume equality for cyclic structures. The algorithm for detecting cyclic
// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
var length = aStack.length;
while (length--) {
// Linear search. Performance is inversely proportional to the number of
// unique nested structures.
if (aStack[length] == a) return bStack[length] == b;
}
// Objects with different constructors are not equivalent, but `Object`s
// from different frames are.
var aCtor = a.constructor, bCtor = b.constructor;
if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
_.isFunction(bCtor) && (bCtor instanceof bCtor))) {
return false;
}
// Add the first object to the stack of traversed objects.
aStack.push(a);
bStack.push(b);
var size = 0, result = true;
// Recursively compare objects and arrays.
if (className == '[object Array]') {
// Compare array lengths to determine if a deep comparison is necessary.
size = a.length;
result = size == b.length;
if (result) {
// Deep compare the contents, ignoring non-numeric properties.
while (size--) {
if (!(result = eq(a[size], b[size], aStack, bStack))) break;
}
}
} else {
// Deep compare objects.
for (var key in a) {
if (_.has(a, key)) {
// Count the expected number of properties.
size++;
// Deep compare each member.
if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
}
}
// Ensure that both objects contain the same number of properties.
if (result) {
for (key in b) {
if (_.has(b, key) && !(size--)) break;
}
result = !size;
}
}
// Remove the first object from the stack of traversed objects.
aStack.pop();
bStack.pop();
return result;
};
// Perform a deep comparison to check if two objects are equal.
_.isEqual = function(a, b) {
return eq(a, b, [], []);
};
// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
_.isEmpty = function(obj) {
if (obj == null) return true;
if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
for (var key in obj) if (_.has(obj, key)) return false;
return true;
};
// Is a given value a DOM element?
_.isElement = function(obj) {
return !!(obj && obj.nodeType === 1);
};
// Is a given value an array?
// Delegates to ECMA5's native Array.isArray
_.isArray = nativeIsArray || function(obj) {
return toString.call(obj) == '[object Array]';
};
// Is a given variable an object?
_.isObject = function(obj) {
return obj === Object(obj);
};
// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
_['is' + name] = function(obj) {
return toString.call(obj) == '[object ' + name + ']';
};
});
// Define a fallback version of the method in browsers (ahem, IE), where
// there isn't any inspectable "Arguments" type.
if (!_.isArguments(arguments)) {
_.isArguments = function(obj) {
return !!(obj && _.has(obj, 'callee'));
};
}
// Optimize `isFunction` if appropriate.
if (typeof (/./) !== 'function') {
_.isFunction = function(obj) {
return typeof obj === 'function';
};
}
// Is a given object a finite number?
_.isFinite = function(obj) {
return isFinite(obj) && !isNaN(parseFloat(obj));
};
// Is the given value `NaN`? (NaN is the only number which does not equal itself).
_.isNaN = function(obj) {
return _.isNumber(obj) && obj != +obj;
};
// Is a given value a boolean?
_.isBoolean = function(obj) {
return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
};
// Is a given value equal to null?
_.isNull = function(obj) {
return obj === null;
};
// Is a given variable undefined?
_.isUndefined = function(obj) {
return obj === void 0;
};
// Shortcut function for checking if an object has a given property directly
// on itself (in other words, not on a prototype).
_.has = function(obj, key) {
return hasOwnProperty.call(obj, key);
};
// Utility Functions
// -----------------
// Run Underscore.js in *noConflict* mode, returning the `_` variable to its
// previous owner. Returns a reference to the Underscore object.
_.noConflict = function() {
root._ = previousUnderscore;
return this;
};
// Keep the identity function around for default iterators.
_.identity = function(value) {
return value;
};
// Run a function **n** times.
_.times = function(n, iterator, context) {
var accum = Array(Math.max(0, n));
for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
return accum;
};
// Return a random integer between min and max (inclusive).
_.random = function(min, max) {
if (max == null) {
max = min;
min = 0;
}
return min + Math.floor(Math.random() * (max - min + 1));
};
// List of HTML entities for escaping.
var entityMap = {
escape: {
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
"'": '&#x27;'
}
};
entityMap.unescape = _.invert(entityMap.escape);
// Regexes containing the keys and values listed immediately above.
var entityRegexes = {
escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
};
// Functions for escaping and unescaping strings to/from HTML interpolation.
_.each(['escape', 'unescape'], function(method) {
_[method] = function(string) {
if (string == null) return '';
return ('' + string).replace(entityRegexes[method], function(match) {
return entityMap[method][match];
});
};
});
// If the value of the named `property` is a function then invoke it with the
// `object` as context; otherwise, return it.
_.result = function(object, property) {
if (object == null) return void 0;
var value = object[property];
return _.isFunction(value) ? value.call(object) : value;
};
// Add your own custom functions to the Underscore object.
_.mixin = function(obj) {
each(_.functions(obj), function(name) {
var func = _[name] = obj[name];
_.prototype[name] = function() {
var args = [this._wrapped];
push.apply(args, arguments);
return result.call(this, func.apply(_, args));
};
});
};
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
_.uniqueId = function(prefix) {
var id = ++idCounter + '';
return prefix ? prefix + id : id;
};
// By default, Underscore uses ERB-style template delimiters, change the
// following template settings to use alternative delimiters.
_.templateSettings = {
evaluate : /<%([\s\S]+?)%>/g,
interpolate : /<%=([\s\S]+?)%>/g,
escape : /<%-([\s\S]+?)%>/g
};
// When customizing `templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;
// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
"'": "'",
'\\': '\\',
'\r': 'r',
'\n': 'n',
'\t': 't',
'\u2028': 'u2028',
'\u2029': 'u2029'
};
var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
_.template = function(text, data, settings) {
var render;
settings = _.defaults({}, settings, _.templateSettings);
// Combine delimiters into one regular expression via alternation.
var matcher = new RegExp([
(settings.escape || noMatch).source,
(settings.interpolate || noMatch).source,
(settings.evaluate || noMatch).source
].join('|') + '|$', 'g');
// Compile the template source, escaping string literals appropriately.
var index = 0;
var source = "__p+='";
text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
source += text.slice(index, offset)
.replace(escaper, function(match) { return '\\' + escapes[match]; });
if (escape) {
source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
}
if (interpolate) {
source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
}
if (evaluate) {
source += "';\n" + evaluate + "\n__p+='";
}
index = offset + match.length;
return match;
});
source += "';\n";
// If a variable is not specified, place data values in local scope.
if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
source = "var __t,__p='',__j=Array.prototype.join," +
"print=function(){__p+=__j.call(arguments,'');};\n" +
source + "return __p;\n";
try {
render = new Function(settings.variable || 'obj', '_', source);
} catch (e) {
e.source = source;
throw e;
}
if (data) return render(data, _);
var template = function(data) {
return render.call(this, data, _);
};
// Provide the compiled function source as a convenience for precompilation.
template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
return template;
};
// Add a "chain" function, which will delegate to the wrapper.
_.chain = function(obj) {
return _(obj).chain();
};
// OOP
// ---------------
// If Underscore is called as a function, it returns a wrapped object that
// can be used OO-style. This wrapper holds altered versions of all the
// underscore functions. Wrapped objects may be chained.
// Helper function to continue chaining intermediate results.
var result = function(obj) {
return this._chain ? _(obj).chain() : obj;
};
// Add all of the Underscore functions to the wrapper object.
_.mixin(_);
// Add all mutator Array functions to the wrapper.
each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
var method = ArrayProto[name];
_.prototype[name] = function() {
var obj = this._wrapped;
method.apply(obj, arguments);
if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
return result.call(this, obj);
};
});
// Add all accessor Array functions to the wrapper.
each(['concat', 'join', 'slice'], function(name) {
var method = ArrayProto[name];
_.prototype[name] = function() {
return result.call(this, method.apply(this._wrapped, arguments));
};
});
_.extend(_.prototype, {
// Start chaining a wrapped Underscore object.
chain: function() {
this._chain = true;
return this;
},
// Extracts the result from a wrapped and chained object.
value: function() {
return this._wrapped;
}
});
}).call(this);
},{}],23:[function(require,module,exports){
// created by @HenrikJoreteg
var prefix;
var isChrome = false;
var isFirefox = false;
var ua = navigator.userAgent.toLowerCase();
// basic sniffing
if (ua.indexOf('firefox') !== -1) {
prefix = 'moz';
isFirefox = true;
} else if (ua.indexOf('chrome') !== -1) {
prefix = 'webkit';
isChrome = true;
}
var PC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
var MediaStream = window.webkitMediaStream || window.MediaStream;
var screenSharing = navigator.userAgent.match('Chrome') && parseInt(navigator.userAgent.match(/Chrome\/(.*) /)[1], 10) >= 26;
var AudioContext = window.webkitAudioContext || window.AudioContext;
// export support flags and constructors.prototype && PC
module.exports = {
support: !!PC,
dataChannel: isChrome || isFirefox || (PC.prototype && PC.prototype.createDataChannel),
prefix: prefix,
webAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
mediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
screenSharing: !!screenSharing,
AudioContext: AudioContext,
PeerConnection: PC,
SessionDescription: SessionDescription,
IceCandidate: IceCandidate
};
},{}],24:[function(require,module,exports){
/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
on @visionmedia's Emitter from UI Kit.
Why? I wanted it standalone.
I also wanted support for wildcard emitters like this:
emitter.on('*', function (eventName, other, event, payloads) {
});
emitter.on('somenamespace*', function (eventName, payloads) {
});
Please note that callbacks triggered by wildcard registered events also get
the event name as the first argument.
*/
module.exports = WildEmitter;
function WildEmitter() {
this.callbacks = {};
}
// Listen on the given `event` with `fn`. Store a group name if present.
WildEmitter.prototype.on = function (event, groupName, fn) {
var hasGroup = (arguments.length === 3),
group = hasGroup ? arguments[1] : undefined,
func = hasGroup ? arguments[2] : arguments[1];
func._groupName = group;
(this.callbacks[event] = this.callbacks[event] || []).push(func);
return this;
};
// Adds an `event` listener that will be invoked a single
// time then automatically removed.
WildEmitter.prototype.once = function (event, groupName, fn) {
var self = this,
hasGroup = (arguments.length === 3),
group = hasGroup ? arguments[1] : undefined,
func = hasGroup ? arguments[2] : arguments[1];
function on() {
self.off(event, on);
func.apply(this, arguments);
}
this.on(event, group, on);
return this;
};
// Unbinds an entire group
WildEmitter.prototype.releaseGroup = function (groupName) {
var item, i, len, handlers;
for (item in this.callbacks) {
handlers = this.callbacks[item];
for (i = 0, len = handlers.length; i < len; i++) {
if (handlers[i]._groupName === groupName) {
//console.log('removing');
// remove it and shorten the array we're looping through
handlers.splice(i, 1);
i--;
len--;
}
}
}
return this;
};
// Remove the given callback for `event` or all
// registered callbacks.
WildEmitter.prototype.off = function (event, fn) {
var callbacks = this.callbacks[event],
i;
if (!callbacks) return this;
// remove all handlers
if (arguments.length === 1) {
delete this.callbacks[event];
return this;
}
// remove specific handler
i = callbacks.indexOf(fn);
callbacks.splice(i, 1);
return this;
};
// Emit `event` with the given args.
// also calls any `*` handlers
WildEmitter.prototype.emit = function (event) {
var args = [].slice.call(arguments, 1),
callbacks = this.callbacks[event],
specialCallbacks = this.getWildcardCallbacks(event),
i,
len,
item;
if (callbacks) {
for (i = 0, len = callbacks.length; i < len; ++i) {
if (callbacks[i]) {
callbacks[i].apply(this, args);
} else {
break;
}
}
}
if (specialCallbacks) {
for (i = 0, len = specialCallbacks.length; i < len; ++i) {
if (specialCallbacks[i]) {
specialCallbacks[i].apply(this, [event].concat(args));
} else {
break;
}
}
}
return this;
};
// Helper for for finding special wildcard event handlers that match the event
WildEmitter.prototype.getWildcardCallbacks = function (eventName) {
var item,
split,
result = [];
for (item in this.callbacks) {
split = item.split('*');
if (item === '*' || (split.length === 2 && eventName.slice(0, split[1].length) === split[1])) {
result = result.concat(this.callbacks[item]);
}
}
return result;
};
},{}]},{},[1])